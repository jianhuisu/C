## 虚拟内存管理的实现原理 

2^10 B = 1 GB , 9* 10^9 * 4B = 3.6 GB

### 虚拟内存管理机制带来了哪些好处

 1. 控制物理内存的访问权限
 1. 使每个进程拥有独立的进程空间  
 1. 便于内存的分配与回收
 1. 扩大了可利用的内存空间
 
等等.

##### 一 虚拟内存管理可以控制物理内存的访问权限

物理内存本身是不限制访问的，任何地址都可以读写，而操作系统要求不同的页面具有不同的访问权限，这是利用CPU模式和MMU的内存保护机制实现的.
操作系统利用体系结构提供的VA到PA的转换机制实现虚拟内存管理.

虚拟地址空间分为`用户空间`和`内核空间`,各种体系结构都有`用户模式(User Mode 用户态)`和`特权模式(Privileged Mode 内核态)`.
在用户模式下执行，不能访问内核空间中的数据，也不能跳转到内核代码中执行.这样可以保护内核.
如果一个进程访问了非法地址，顶多这一个进程崩溃，而不会影响到内核和整个系统的稳定性.

以段错误异常的产生为例子说明:

 1. 用户程序要访问的一个VA，经MMU检查无权访问.
 1. MMU产生一个异常，CPU从用户模式切换到特权模式，跳转到内核代码中执行异常服务程序.
 1. 内核把这个异常解释为段错误，把引发异常的进程终止掉.

注释:异常的**处理过程**和中断类似，但是两者的**产生原因**不同.
 
 - 中断产生的原因和CPU当前执行的指令无关，中断由外部设备产生.比如键盘输入`ctrl + c`终止当前进程执行.
 - 异常的产生就是由于CPU当前执行的指令出了问题.比如除法指令的除数为0等都会产生异常.

##### 二 虚拟内存管理最主要的作用是让每个进程有独立的地址空间
 
**相同的VA怎么会有不同的数据呢**？因为它们被映射到不同的PA.
**每个进程都有自己的一套VA到PA的映射表**，整个地址空间中的任何VA都在每个进程自己的映射表中查找相应的PA，
因此不可能访问到其它进程的地址，也就没有可能意外改写其它进程的数据.
注意到两个进程的共享库加载地址并不相同，共享库的加载地址是在运行时决定的，而不是写在/bin/bash这个可执行文件中.
但即使如此，也不影响两个进程共享相同物理页面中的共享库，注意，只有只读的部分是共享的，可读可写的部分不共享.

##### 三 便于内存的分配与释放

VA到PA的映射会给分配和释放内存带来方便，物理地址不连续的几块内存可以映射成虚拟地址连续的一块内存.

##### 第四 扩大内存使用空间

一个系统如果同时运行着很多进程，**为各进程分配的内存之和可能会大于实际可用的物理内存**，
虚拟内存管理使得这种情况下各进程仍然能够正常运行.
因为各进程分配的只不过是虚拟内存的页面，这些页面的数据可以映射到物理页面，也可以临时保存到磁盘上而不占用物理页面，
在磁盘上临时保存虚拟内存页面的可能是一个磁盘分区，也可能是一个磁盘文件，称为交换设备`(Swap Device)`.
当物理内存不够用时，将一些不常用的物理页面中的数据临时保存到交换设备，然后这个物理页面就认为是空闲的了，可以重新分配给进程使用，
这个过程称为`换出(Page out)`.如果进程要用到被换出的页面，就从交换设备再加载回物理内存，这称为`换入(Page in)`.换出和换入操作统称为`换页(Paging)`.
因此：**系统中可分配的内存总量 = 物理内存的大小 + 交换设备的大小**

#### Linux进程内存映射分析工具:`pmap`

    [sujianhui@nlp a_test]$ ps
      PID TTY          TIME CMD
     4774 pts/1    00:00:00 bash
    14124 pts/1    00:00:00 ps

`pmap 4774` <=> `cat /proc/4774/maps` 输出内容基本类似,`pmap`,最后一行汇总了进程占用空间的总计.更友好一些.`cat /proc/4774/maps`输出更详细一些.
    
    $ ps
      PID TTY          TIME CMD
    29977 pts/0    00:00:00 bash
    30032 pts/0    00:00:00 ps
    $ cat /proc/29977/maps 
    08048000-080f4000 r-xp 00000000 08:15 688142     /bin/bash
    080f4000-080f9000 rw-p 000ac000 08:15 688142     /bin/bash
    080f9000-080fe000 rw-p 080f9000 00:00 0 
    09283000-09497000 rw-p 09283000 00:00 0          [heap]
    b7ca8000-b7cb2000 r-xp 00000000 08:15 581665     /lib/tls/i686/cmov/libnss_files-2.8.90.so
    b7cb2000-b7cb3000 r--p 00009000 08:15 581665     /lib/tls/i686/cmov/libnss_files-2.8.90.so
    b7cb3000-b7cb4000 rw-p 0000a000 08:15 581665     /lib/tls/i686/cmov/libnss_files-2.8.90.so
    ...
    b7e15000-b7f6d000 r-xp 00000000 08:15 581656     /lib/tls/i686/cmov/libc-2.8.90.so
    b7f6d000-b7f6f000 r--p 00158000 08:15 581656     /lib/tls/i686/cmov/libc-2.8.90.so
    b7f6f000-b7f70000 rw-p 0015a000 08:15 581656     /lib/tls/i686/cmov/libc-2.8.90.so
    ...
    b7fbd000-b7fd7000 r-xp 00000000 08:15 565466     /lib/ld-2.8.90.so
    b7fd7000-b7fd8000 r-xp b7fd7000 00:00 0          [vdso]
    b7fd8000-b7fd9000 r--p 0001a000 08:15 565466     /lib/ld-2.8.90.so
    b7fd9000-b7fda000 rw-p 0001b000 08:15 565466     /lib/ld-2.8.90.so
    bfac5000-bfada000 rw-p bffeb000 00:00 0          [stack]

`0x0804 8000-0x080f 4000`是从`/bin/bash`(注释:也就是说从磁盘文件/bin/bash)加载到内存的，访问权限为`r-x`，表示`Text Segment`，
包含`.text` section、`.rodata` section、`.plt` section等。`0x080f 4000-0x080f 9000`也是从`/bin/bash`加载到内存的，
访问权限为rw-，表示`Data Segment`，包含`.data` section、`.bss` section 等。


    .rodata 只读数据段
    .comment 注释信息段
    .text 只读数据段
    .rodata 只读数据段
    .rodata 只读数据段
    .rodata 只读数据段
    .rodata 只读数据段


    Segment  A
        
        section.1
        section.2
        section.3
        ...
        
    Segment  B
        
        section.1
        section.2
        section.3
        ...
    

注意: `Segment` 与 `section` 在很多文献中翻译为中文都称呼为`段`，注意区别.
ELF格式提供了两种不同的视角，链接器把ELF文件看成是`Section`的集合，而加载器把ELF文件看成是`Segment`的集合

`0x0928 3000-0x0949 7000`不是从磁盘文件加载到内存的，这段空间称为`堆 Heap`，以后会讲到用`malloc`函数动态分配内存是在这里分配的。

从`0xb7ca 8000`开始是共享库的映射空间，每个共享库也分为几个`Segment`，每个`Segment`有不同的访问权限。

从堆空间的结束地址（0x0949 7000）到共享库映射空间的起始地址（0xb7ca 8000）之间有很大的地址空洞，在动态分配内存时堆空间是可以向高地址增长的。
堆空间的地址上限（0x09497000）称为`Break`，堆空间要向高地址增长就要抬高`Break`，映射新的虚拟内存页面到物理内存，这是通过系统调用`brk`实现的，
malloc函数也是调用brk向内核请求分配内存的。

`0xbfac 5000-0xbfad a000`是栈空间，其中`高地址`的部分保存着进程的环境变量和命令行参数，`低地址`的部分保存函数栈帧，栈空间是`向低地址增长`的，
但显然没有堆空间那么大的可供增长的余地，因为实际的应用程序动态分配大量内存的并不少见，但是有几十层深的函数调用并且每层调用都有很多局部变量的非常少见。
总之，**栈空间是可能用尽的，并且比堆空间更容易用尽**(注释:所以我们在函数内要避免使用过大的变量,可以使用指针代替)

### 参考资料

http://akaedu.github.io/book/ch17s04.html

http://akaedu.github.io/book/ch20s05.html#link.vm






























## 程序的编译 链接与装入

内存(内存条) 掉电 数据丢失  
外存(硬盘) 掉电 数据存在

主存储器别名：
	内存
	主存
	可执行存储器

### 计算机系统存储器多层结构


todo 寄存器的字长
todo 同一个名词使用在不同的场景中 具有不同的意义

磁盘中的数据必须先load到主存才可以使用
同样 数据必须先load到主存 才可以输出到辅存


### 2 程序的链接

目前 程序的链接分为三种方式 
    
    静态链接
    装入时动态链接  装入时将所有模块都进行链接
    运行时动态链接  运行时只链接需要的模块        比如 错误处理模块 如果程序运行过程中 没有发生错误 那么这个模块就是无用的

###  3 relocation 

装入时对目标程序中指令和数据地址的修改过程称为重定位


程序运行的顺序是 (编译 链接 装入 ， 链接在装入之后)

装入的方式有三种 

    绝对装入方式  : 编译后产生绝对的物理地址, 只允许将程序装载到内存中的固定位置  适合单道程序
    可重定位装入方式 : 允许将程序程序装载到内存中的固定位置 ，但是 进程经过换入换出后 , 在内存中的物地址不能发生移动, 进程装入后确定物理地址 
    动态运行时的装入方式 ： 允许进程换入换出后改变物理地址 逻辑地址与物理地址的转换发生在 进程从就绪态转化到执行态 ，进程装载所有的地址仍然时 逻辑地址 


各数据地址 ，指令地址 都是根据目标的起始地址经过偏移计算(offset sum)得出
装入后 逻辑地址被转化为物理地址

地址变换通常是在进程装入时一次完成,以后不再改变 ，所以称为 静态重定位

动态运行的装入程序在把装入模块装入内存后,并不立即把装入模块中的`逻辑地址`转化为`物理地址`
(
所以 编译产生的目标文件中的地址都是逻辑地址 其起始地址都是从逻辑地址上的 0x000000000000 开始
其中 每个段的地址都是相对于起始地址计算的
) 如下_

    
    [guangsu@xuwei 10:36:15 ~/CLionProjects/Test]$gcc -c main.c -o main.o
    [guangsu@xuwei 10:36:15 ~/CLionProjects/Test]$objdump -dS main.o
    
    main.o:     file format elf64-x86-64
    
    Disassembly of section .text:
    
    0000000000000000 <swap>:
       0:   55                      push   %rbp
       1:   48 89 e5                mov    %rsp,%rbp
       4:   48 89 7d e8             mov    %rdi,-0x18(%rbp)
       ...
      30:   c3                      retq   
       ...
    
    0000000000000031 <main>:
      31:   55                      push   %rbp
      32:   48 89 e5                mov    %rsp,%rbp
      35:   48 83 ec 40             sub    $0x40,%rsp
      39:   89 7d cc                mov    %edi,-0x34(%rbp)
      ...
      dd:   c9                      leaveq 
      de:   c3                      retq   

对完成`编译链接`的a.out 进行反汇编(汇编指令有删减,只须观察segment的起始地址变化)

    [guangsu@xuwei 10:41:01 ~/CLionProjects/Test]$objdump -dS a.out 
    
    a.out:     file format elf64-x86-64
    
    
    Disassembly of section .init:
    
    00000000004003e0 <_init>:
      4003e0:	48 83 ec 08          	sub    $0x8,%rsp
      4003e4:	48 8b 05 0d 0c 20 00 	mov    0x200c0d(%rip),%rax        # 600ff8 <__gmon_start__>
      4003f9:	c3                   	retq   
    
    Disassembly of section .plt:
    
    0000000000400400 <.plt>:
      400400:	ff 35 02 0c 20 00    	pushq  0x200c02(%rip)        # 601008 <_GLOBAL_OFFSET_TABLE_+0x8>
      400406:	ff 25 04 0c 20 00    	jmpq   *0x200c04(%rip)        # 601010 <_GLOBAL_OFFSET_TABLE_+0x10>
      40040c:	0f 1f 40 00          	nopl   0x0(%rax)
    
    0000000000400410 <printf@plt>:
      400410:	ff 25 02 0c 20 00    	jmpq   *0x200c02(%rip)        # 601018 <printf@GLIBC_2.2.5>
      400416:	68 00 00 00 00       	pushq  $0x0
      40041b:	e9 e0 ff ff ff       	jmpq   400400 <.plt>
    
    0000000000400420 <__libc_start_main@plt>:
      400420:	ff 25 fa 0b 20 00    	jmpq   *0x200bfa(%rip)        # 601020 <__libc_start_main@GLIBC_2.2.5>
      400426:	68 01 00 00 00       	pushq  $0x1
      40042b:	e9 d0 ff ff ff       	jmpq   400400 <.plt>
    
    0000000000400430 <__gmon_start__@plt>:
      400430:	ff 25 f2 0b 20 00    	jmpq   *0x200bf2(%rip)        # 601028 <__gmon_start__>
      400436:	68 02 00 00 00       	pushq  $0x2
      40043b:	e9 c0 ff ff ff       	jmpq   400400 <.plt>
    
    Disassembly of section .text:
    
    0000000000400440 <_start>:
      400440:	31 ed                	xor    %ebp,%ebp
      400442:	49 89 d1             	mov    %rdx,%r9
      40046a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    
    0000000000400470 <deregister_tm_clones>:
      400470:	b8 3f 10 60 00       	mov    $0x60103f,%eax
      400475:	55                   	push   %rbp
      400497:	ff e0                	jmpq   *%rax
      400499:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    
    00000000004004a0 <register_tm_clones>:
      4004a0:	b8 38 10 60 00       	mov    $0x601038,%eax
      4004a5:	55                   	push   %rbp
      4004d9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    
    00000000004004e0 <__do_global_dtors_aux>:
      4004e0:	80 3d 4d 0b 20 00 00 	cmpb   $0x0,0x200b4d(%rip)        # 601034 <_edata>
      4004fc:	0f 1f 40 00          	nopl   0x0(%rax)
    
    0000000000400500 <frame_dummy>:
      400500:	48 83 3d 18 09 20 00 	cmpq   $0x0,0x200918(%rip)        # 600e20 <__JCR_END__>
      400507:	00 
    
    000000000040052d <swap>:
      40052d:	55                   	push   %rbp
      40052e:	48 89 e5             	mov    %rsp,%rbp
      40055c:	5d                   	pop    %rbp
      40055d:	c3                   	retq   
    
    000000000040055e <main>:
      40055e:	55                   	push   %rbp
      400676:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
      40067d:	00 00 00 
    
    0000000000400680 <__libc_csu_fini>:
      400680:	f3 c3                	repz retq 
    
    Disassembly of section .fini:
    
    0000000000400684 <_fini>:
      400684:	48 83 ec 08          	sub    $0x8,%rsp
      400688:	48 83 c4 08          	add    $0x8,%rsp
      40068c:	c3                   	retq   


## 存储管理方式 

操作系统在内存的低址部分 用户程序在内存地址的高址部分  ， 这就相当于 君住长江头 我住长江尾 日日思君不见君 共饮长江水

查看某个进程的逻辑地址空间
然后用cat /proc/29977/maps命令查看它的虚拟地址空间
用pmap 29977命令也可以得到类似的输出结果


操作系统在内存的高地址还是低地址?

从物理内存地址而言，一般都是放在低地址.
从虚拟内存地址而言，一般都是放在高地址.


todo 
