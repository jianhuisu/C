## 虚拟内存管理的实现原理 

### 虚拟内存管理机制带来了哪些好处

 1. 控制物理内存的访问权限
 1. 使每个进程拥有独立的进程空间  
 1. 便于内存的分配与回收
 1. 扩大了可利用的内存空间
 
等等.

##### 一 虚拟内存管理可以控制物理内存的访问权限

物理内存本身是不限制访问的，任何地址都可以读写，而操作系统要求不同的页面具有不同的访问权限，这是利用CPU模式和MMU的内存保护机制实现的.
操作系统利用体系结构提供的VA到PA的转换机制实现虚拟内存管理.

虚拟地址空间分为`用户空间`和`内核空间`,各种体系结构都有`用户模式(User Mode 用户态)`和`特权模式(Privileged Mode 内核态)`.
在用户模式下执行，不能访问内核空间中的数据，也不能跳转到内核代码中执行.这样可以保护内核.
如果一个进程访问了非法地址，顶多这一个进程崩溃，而不会影响到内核和整个系统的稳定性.

以段错误异常的产生为例子说明:

 1. 用户程序要访问的一个VA，经MMU检查无权访问.
 1. MMU产生一个异常，CPU从用户模式切换到特权模式，跳转到内核代码中执行异常服务程序.
 1. 内核把这个异常解释为段错误，把引发异常的进程终止掉.

注释:异常的**处理过程**和中断类似，但是两者的**产生原因**不同.
 
 - 中断产生的原因和CPU当前执行的指令无关，中断由外部设备产生.比如键盘输入`ctrl + c`终止当前进程执行.
 - 异常的产生就是由于CPU当前执行的指令出了问题.比如除法指令的除数为0等都会产生异常.

##### 二 虚拟内存管理最主要的作用是让每个进程有独立的地址空间
 
相同的VA怎么会有不同的数据呢？因为它们被映射到不同的PA.
**每个进程都有自己的一套VA到PA的映射表**，整个地址空间中的任何VA都在每个进程自己的映射表中查找相应的PA，
因此不可能访问到其它进程的地址，也就没有可能意外改写其它进程的数据.
注意到两个进程的共享库加载地址并不相同，共享库的加载地址是在运行时决定的，而不是写在/bin/bash这个可执行文件中.
但即使如此，也不影响两个进程共享相同物理页面中的共享库，注意，只有只读的部分是共享的，可读可写的部分不共享.

##### 三 便于内存的分配与释放

VA到PA的映射会给分配和释放内存带来方便，物理地址不连续的几块内存可以映射成虚拟地址连续的一块内存.

##### 第四 扩大内存使用空间

一个系统如果同时运行着很多进程，**为各进程分配的内存之和可能会大于实际可用的物理内存**，
虚拟内存管理使得这种情况下各进程仍然能够正常运行.
因为各进程分配的只不过是虚拟内存的页面，这些页面的数据可以映射到物理页面，也可以临时保存到磁盘上而不占用物理页面，
在磁盘上临时保存虚拟内存页面的可能是一个磁盘分区，也可能是一个磁盘文件，称为交换设备`(Swap Device)`.
当物理内存不够用时，将一些不常用的物理页面中的数据临时保存到交换设备，然后这个物理页面就认为是空闲的了，可以重新分配给进程使用，
这个过程称为`换出(Page out)`.如果进程要用到被换出的页面，就从交换设备再加载回物理内存，这称为`换入(Page in)`.换出和换入操作统称为`换页(Paging)`.
因此：**系统中可分配的内存总量 = 物理内存的大小 + 交换设备的大小**

#### Linux进程内存分析`pmap`命令

将最高的 1G字节(从虚拟地址0xC0000000到0xFFFFFFFF)，供内核使用，称为“内核空间”.
而将较低的3G字节(从虚拟地址 0x00000000到0xBFFFFFFF)，供各个进程使用，称为“用户空间)
从进程的角度来看，每个进程可以拥有4G字节的虚拟空间.？ todo 这个从哪里看呢？每个进程有各自的私有用户空间(0～3G)，这个空间对系统中的其他进程是不可见的.
什么是内存泄露？
目测可能因为malloc触发了一次系统调用，从系统中申请了4k内存，而free只是在应用层进行了释放，

没有触发系统调用，而没有向系统归还这4k.

你下次如果再次malloc 4k以内的内存，这块内存会被应用层重用，也不会触发系统调用了.

### 参考资料

http://akaedu.github.io/book/ch17s04.html

http://akaedu.github.io/book/ch20s05.html#link.vm






























## 程序的编译 链接与装入

内存(内存条) 掉电 数据丢失  
外存(硬盘) 掉电 数据存在

主存储器别名：
	内存
	主存
	可执行存储器

### 计算机系统存储器多层结构


todo 寄存器的字长
todo 同一个名词使用在不同的场景中 具有不同的意义

磁盘中的数据必须先load到主存才可以使用
同样 数据必须先load到主存 才可以输出到辅存


### 2 程序的链接

目前 程序的链接分为三种方式 
    
    静态链接
    装入时动态链接  装入时将所有模块都进行链接
    运行时动态链接  运行时只链接需要的模块        比如 错误处理模块 如果程序运行过程中 没有发生错误 那么这个模块就是无用的

###  3 relocation 

装入时对目标程序中指令和数据地址的修改过程称为重定位


程序运行的顺序是 (编译 链接 装入 ， 链接在装入之后)

装入的方式有三种 

    绝对装入方式  : 编译后产生绝对的物理地址, 只允许将程序装载到内存中的固定位置  适合单道程序
    可重定位装入方式 : 允许将程序程序装载到内存中的固定位置 ，但是 进程经过换入换出后 , 在内存中的物地址不能发生移动, 进程装入后确定物理地址 
    动态运行时的装入方式 ： 允许进程换入换出后改变物理地址 逻辑地址与物理地址的转换发生在 进程从就绪态转化到执行态 ，进程装载所有的地址仍然时 逻辑地址 


各数据地址 ，指令地址 都是根据目标的起始地址经过偏移计算(offset sum)得出
装入后 逻辑地址被转化为物理地址

地址变换通常是在进程装入时一次完成,以后不再改变 ，所以称为 静态重定位

动态运行的装入程序在把装入模块装入内存后,并不立即把装入模块中的`逻辑地址`转化为`物理地址`
(
所以 编译产生的目标文件中的地址都是逻辑地址 其起始地址都是从逻辑地址上的 0x000000000000 开始
其中 每个段的地址都是相对于起始地址计算的
) 如下_

    
    [guangsu@xuwei 10:36:15 ~/CLionProjects/Test]$gcc -c main.c -o main.o
    [guangsu@xuwei 10:36:15 ~/CLionProjects/Test]$objdump -dS main.o
    
    main.o:     file format elf64-x86-64
    
    Disassembly of section .text:
    
    0000000000000000 <swap>:
       0:   55                      push   %rbp
       1:   48 89 e5                mov    %rsp,%rbp
       4:   48 89 7d e8             mov    %rdi,-0x18(%rbp)
       ...
      30:   c3                      retq   
       ...
    
    0000000000000031 <main>:
      31:   55                      push   %rbp
      32:   48 89 e5                mov    %rsp,%rbp
      35:   48 83 ec 40             sub    $0x40,%rsp
      39:   89 7d cc                mov    %edi,-0x34(%rbp)
      ...
      dd:   c9                      leaveq 
      de:   c3                      retq   

对完成`编译链接`的a.out 进行反汇编(汇编指令有删减,只须观察segment的起始地址变化)

    [guangsu@xuwei 10:41:01 ~/CLionProjects/Test]$objdump -dS a.out 
    
    a.out:     file format elf64-x86-64
    
    
    Disassembly of section .init:
    
    00000000004003e0 <_init>:
      4003e0:	48 83 ec 08          	sub    $0x8,%rsp
      4003e4:	48 8b 05 0d 0c 20 00 	mov    0x200c0d(%rip),%rax        # 600ff8 <__gmon_start__>
      4003f9:	c3                   	retq   
    
    Disassembly of section .plt:
    
    0000000000400400 <.plt>:
      400400:	ff 35 02 0c 20 00    	pushq  0x200c02(%rip)        # 601008 <_GLOBAL_OFFSET_TABLE_+0x8>
      400406:	ff 25 04 0c 20 00    	jmpq   *0x200c04(%rip)        # 601010 <_GLOBAL_OFFSET_TABLE_+0x10>
      40040c:	0f 1f 40 00          	nopl   0x0(%rax)
    
    0000000000400410 <printf@plt>:
      400410:	ff 25 02 0c 20 00    	jmpq   *0x200c02(%rip)        # 601018 <printf@GLIBC_2.2.5>
      400416:	68 00 00 00 00       	pushq  $0x0
      40041b:	e9 e0 ff ff ff       	jmpq   400400 <.plt>
    
    0000000000400420 <__libc_start_main@plt>:
      400420:	ff 25 fa 0b 20 00    	jmpq   *0x200bfa(%rip)        # 601020 <__libc_start_main@GLIBC_2.2.5>
      400426:	68 01 00 00 00       	pushq  $0x1
      40042b:	e9 d0 ff ff ff       	jmpq   400400 <.plt>
    
    0000000000400430 <__gmon_start__@plt>:
      400430:	ff 25 f2 0b 20 00    	jmpq   *0x200bf2(%rip)        # 601028 <__gmon_start__>
      400436:	68 02 00 00 00       	pushq  $0x2
      40043b:	e9 c0 ff ff ff       	jmpq   400400 <.plt>
    
    Disassembly of section .text:
    
    0000000000400440 <_start>:
      400440:	31 ed                	xor    %ebp,%ebp
      400442:	49 89 d1             	mov    %rdx,%r9
      40046a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    
    0000000000400470 <deregister_tm_clones>:
      400470:	b8 3f 10 60 00       	mov    $0x60103f,%eax
      400475:	55                   	push   %rbp
      400497:	ff e0                	jmpq   *%rax
      400499:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    
    00000000004004a0 <register_tm_clones>:
      4004a0:	b8 38 10 60 00       	mov    $0x601038,%eax
      4004a5:	55                   	push   %rbp
      4004d9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    
    00000000004004e0 <__do_global_dtors_aux>:
      4004e0:	80 3d 4d 0b 20 00 00 	cmpb   $0x0,0x200b4d(%rip)        # 601034 <_edata>
      4004fc:	0f 1f 40 00          	nopl   0x0(%rax)
    
    0000000000400500 <frame_dummy>:
      400500:	48 83 3d 18 09 20 00 	cmpq   $0x0,0x200918(%rip)        # 600e20 <__JCR_END__>
      400507:	00 
    
    000000000040052d <swap>:
      40052d:	55                   	push   %rbp
      40052e:	48 89 e5             	mov    %rsp,%rbp
      40055c:	5d                   	pop    %rbp
      40055d:	c3                   	retq   
    
    000000000040055e <main>:
      40055e:	55                   	push   %rbp
      400676:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
      40067d:	00 00 00 
    
    0000000000400680 <__libc_csu_fini>:
      400680:	f3 c3                	repz retq 
    
    Disassembly of section .fini:
    
    0000000000400684 <_fini>:
      400684:	48 83 ec 08          	sub    $0x8,%rsp
      400688:	48 83 c4 08          	add    $0x8,%rsp
      40068c:	c3                   	retq   


## 存储管理方式 

操作系统在内存的低址部分 用户程序在内存地址的高址部分  ， 这就相当于 君住长江头 我住长江尾 日日思君不见君 共饮长江水

查看某个进程的逻辑地址空间
然后用cat /proc/29977/maps命令查看它的虚拟地址空间
用pmap 29977命令也可以得到类似的输出结果


操作系统在内存的高地址还是低地址?

从物理内存地址而言，一般都是放在低地址.
从虚拟内存地址而言，一般都是放在高地址.


todo 
