## 虚拟内存管理

### 内存单元

**一个内存单元的大小为8bits，是一串8比特的二进制数.**

每个内存单元有一个地址（Address），内存地址是从0开始编号的整数.CPU通过地址找到相应的内存单元，取其中的指令或者读写其中的数据。
一个地址所对应的内存单元不能存很多东西，只能存一个字节，int、float等多字节的数据类型保存在内存中要占用连续的多个地址，这种情况下数据的地址是它所占内存单元的起始地址.
所以:**内存地址是以字节为单位的**(原因取决于物理内存芯片的构造 https://www.jianshu.com/p/bc8252f18ecf)

    eg.0x7ffe6d29de5c 代表 序号为 0x7ffe6d29de5c 的Byte 

### 内存地址

现代操作系统普遍采用虚拟内存管理（Virtual Memory Management）机制，
这需要处理器中的`MMU`（Memory Management Unit，内存管理单元）提供支持，本节简要介绍MMU的作用。
(注释:注意,MMU是CPU组成的一部分,集成在CPU芯片上)

#### 物理地址  Physical Address  简称PA

如果处理器没有MMU，或者有MMU但没有启用，CPU执行单元发出的内存地址将直接发送到CPU芯片的外部地址引脚，
然后通过总线传递,被内存芯片（以下称为物理内存,也就是我们常说的内存条，以便与虚拟内存区分）接收，
(注释:此时CPU执行单元发出的内存与传递到CPU芯片外部地址引脚上的地址是相同的),这个地址称为物理地址.

#### 虚地址    Virtual Address，简称VA

如果处理器启用了MMU，CPU执行单元发出的内存地址将被MMU截获，
从CPU传递到MMU的地址称为虚拟地址（Virtual Address，以下简称VA），
(注释:这也意味着，我们源码编译完成后,目标文件中的可以确定的地址是虚地址).
MMU将这个地址翻译(注释：这个翻译的动作 我们通常称为将VA映射成PA)成另一个地址,
然后将翻译后得出的地址发到CPU芯片的外部地址引脚上，被内存芯片接收.
(注释:此时CPU执行单元发出的内存与传递到CPU芯片外部地址引脚上的地址是不相同的，前者为虚地址,后者为物理地址)

#### 地址空间的大小

如果是32位处理器，则内地址总线是32位的，与CPU执行单元相连（书中原图中只是示意性地画了4条地址线,可以移步原书进行参考），
而经过MMU转换之后的外地址总线则不一定是32位的。
也就是说，**虚拟地址空间和物理地址空间是独立的**，
32位处理器的虚拟地址空间是4GB，而物理地址空间既可以大于也可以小于4GB。

!!!注释:这里注意区别内地址总线，外地址总线两个概念.(总线的相关知识请自行查阅)
`内地址总线`是CPU芯片内部组成中的`CPU执行单元`与`MMU`之间连接总线的条数,并且与CPU的位数相同.
`外地址总线`是CPU芯片外部地址引脚的个数

以上文为例子进行推导:

    32位处理器
    => 内地址总线是32位(这里的32位是指内地址总线由32条单线族称组成,可以理解位32个引脚)
    => 虚地址宽度为32位

        (注释:我的电脑是64位的centos7.7 readelf -a 一个可执行文件，里面的虚地址展示如下)
        Dynamic section at offset 0xe28 contains 24 entries:
          Tag        Type                         Name/Value
         0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
         0x000000000000000c (INIT)               0x4003e0
         0x000000000000000d (FINI)               0x4005d4
         0x0000000000000019 (INIT_ARRAY)         0x600e10
        ...

        `0x0000000000000019`地址宽度为16位十六进制数字,转换为二进制则为(16 * 4) => 64 位二进制,正好与我的处理器位数相互印证.
        todo 本条注释还未验证，可忽略，
        有些部分说明 虚地址里的 1 代表一个字节（指针+1），这可把我搞糊涂了............

    => 则虚拟地址空间 (2^32) Bytes （注释:其实称为最大寻址空间更为贴切）
    => 2^22 KB
    => 2^12 MB
    => 2^2 GB
    => 4GB (简称)

这里有几个Tips要了解一下：

 - 我的CPU是32位,那么我的最大虚拟地址空间为`4GB`，换而言之，就是说32位系统的处理器最大只支持到4G内存，如果你搞一个32位处理器+8G内存条的搭配,纯属浪费.
 - 我的CPU是64位,那么我的最大虚拟地址空间为`2^34 GB`,最大支持的内存高达亿位数.
 - 现在市场上的CPU一般都是64位的，但是这些CPU并不是真正意义上的64位CPU，里面依然保留了大部分32位的技术(为了处理软件的兼容性)，只是进行了部分64位的改进。
 - 操作系统把虚拟地址空间划分为用户空间和内核空间，例如x86平台的Linux系统虚拟地址空间是0x00000000~0xffffffff，前3GB（0x00000000~0xbfffffff）是用户空间，
   后1GB（0xc0000000~0xffffffff）是内核空间。
 
有时我们查看CPU信息时，有这样一条说明:
 
    [sujianhui@nlp a_test]$ cat /proc/cpuinfo | grep 'address sizes'
    address sizes	: 39 bits physical, 48 bits virtual
    address sizes	: 39 bits physical, 48 bits virtual
    address sizes	: 39 bits physical, 48 bits virtual
    address sizes	: 39 bits physical, 48 bits virtual

这是因为,虽然CPU内总线64位,但是只提供低48位给用户使用,虽然少了16位,但是也足够了.
`39 bits physical`，应该指的CPU外引脚数为39个吧（这个结论没有论证过,仅供参考,待后续印证）
 



