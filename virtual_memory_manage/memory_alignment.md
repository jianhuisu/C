## 内存对齐
    
    #include <stdio.h>

    int main(int argc, char** argv)
    {
        struct {
            char a;
            short b;
            int c;
            char d;
        } s;
    
        s.a = 1;
        s.b = 2;
        s.c = 3;
        s.d = 4;
        printf("%u\n", sizeof(s));
    
        return 0;
    }

结构体的各成员并不是一个紧挨一个排列的，中间有空隙，称为填充`（Padding）`.
不仅如此，在这个结构体的末尾也有三个字节的填充，所以`sizeof(s)`的值是`12`。
注意，`printf`的`%u`转换说明表示无符号数，`sizeof`的值是`size_t`类型的，是某种无符号整型。
为什么编译器要这样处理呢？
在32位平台上，访问4字节的指令（比如上面的`movl`）所访问的内存地址应该是4的整数倍，
访问两字节的指令（比如上面的`movw`）所访问的内存地址应该是两字节的整数倍，这称为对齐（Alignment）。
如果指令所访问的内存地址没有正确对齐会怎么样呢？在有些平台上将不能访问内存，而是引发一个异常，在x86平台上倒是仍然能访问内存，
**但是不对齐的指令执行效率比对齐的指令要低**，所以编译器在安排各种变量的地址时都会考虑到对齐的问题。
对于本例中的结构体，编译器会把它的基地址对齐到4字节边界，也就是说，`ebp-0x10`这个地址一定是4的整数倍。
`s.a`占一个字节，没有对齐的问题。`s.b`占两个字节，如果`s.b`紧挨在`s.a`后面，它的地址就不能是两字节的整数倍了.
所以编译器会在结构体中插入一个填充字节，使`s.b`的地址也是两字节的整数倍。
s.c占4字节，紧挨在s.b的后面就可以了，因为`ebp-0xc`这个地址也是4的整数倍。
那么`s.d`已经是结构体的最后一个元素了,为什么`s.d`的后面也要有填充位填充到4字节边界呢？
这是为了便于安排这个结构体后面的变量的地址，假如用这种结构体类型组成一个数组，
那么后一个结构体只需和前一个结构体紧挨着排列就可以保证它的基地址仍然对齐到4字节边界了，因为在前一个结构体的末尾已经有了填充字节。
事实上，C标准规定数组元素必须紧挨着排列，不能有空隙，这样才能保证每个元素的地址可以按`基地址+n×元素大小`简单计算出来。
合理设计结构体各成员的排列顺序可以节省存储空间，例如上例中的结构体改成这样就可以避免产生填充字节：

    struct {
        char a;
        char d;
        short b;
        int c;
    } s;
    
注释:结构体中成员的书写顺序有可能会决定寻址效率.    