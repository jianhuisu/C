//
// 二叉树顺序存储结构实现
//

// 使用一组地址连续的存储的单元一次自上而下，自左而右的存储 完全二叉树上的结点元素
// 即：使用C的一维数组,按自上而下，自左而右的顺序 存储完全二叉树上的结点元素 ，一维数组的每个分量对应二叉树的一个结点。
// 将完全二叉树上编号为i的结点元素存储在以上一维数组中下标为(i-1)的分量中,结点为空时将数组中对应分量的值设置为0
//  eg. 假设二叉树的结点值为一个正整数.现在有一个一维C整数数组 int seq_binary_tree[8] = ['a','b','c','d','e','f','g']
//  按照先序遍历的顺序解析，构建为一个满二叉树，其图形结构为
/**
 *                      a
 *                   b     c
 *                 d  e  f  g
 * */
// 结论：
// 1 顺序存储结构仅适用于完全二叉树,一课普通的单枝二叉树会存储大量冗余的 0 分量.
// 2 单独一种的遍历方式无法唯一的确定一棵二叉树的形态，前序和中序遍历的结果合在一起可以唯一确定二叉树的形态，也就是说根据遍历结果可以构造出二叉树

#include <stdio.h>

#define MAX_TREE_SIZE 100  // 二叉树可以容纳的最大节点数 2^k - 1 = 100  ,所以深度k最大为7


int main(void)
{
    printf("hello \n");
}