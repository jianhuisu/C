## pointer 

###  

todo 

我们知道，调用函数的传参过程相当于用实参定义并初始化形参，swap(&i, &j)这个调用相当于

char name='A'
&name => 0x7ffce3e36e1f

pointer var's value is 48bits address(12 position hex number equal 48 bits)  / why ?
so 6(48/8) bytes this char pointer var occupied 


内存地址是12位16进制数，那么对应的指针需要多少字节？
例如（对变量取址得到的）：0x7fff5ced2e5c;
那么就是12个4位的2进制数，就是48位的2进制数，48/8 = 6，那就是6个字节可以表示48位的2进制数。但是我储存一个指针（利用sizeof求得）需要8字节，另外两个字节我推测是用来存储这个指针所指变量的长度。
例如 int 的指针 p，使用 p+1， 则对应的地址偏移4个字节。
>>>
我的问题是，我上面一堆话说得对吗？
此外，我是非专业的业余爱好者，所以请不要鄙视我不懂某些基础知识。

指针是8字节没问题，但另两个字节也是地址的组成部分，并无它用。可以这样想，在windows系统上，如果你对函数临时变量取值，
很可能得到0x13ff58这样一个6位16进制数地址(3 bytes)，那么剩下5个字节都做其它用了吗？
地址数值只有48位是表像，实际上它是64位的地址，这是当前的x86_64处理器硬件限制所致。
因为目前面世的x86_64处理器的地址线只有48条，硬件要求传入的地址的48到63位必须与47位相同。
因此有两段合法的地址空间，
最直观的是0 - 0x00007fff ffffffff，另
一段是0xffff8000 00000000 - 0xffffffff ffffffff。
两段加在一起一共2^48 = 256TB，

这就是当前处理器的寻址能力。
但一般我们是见不到第二段地址的，因为操作系统一般使用低段地址，
高段这部分需要你的机器至少有128TB以上的内存。()

、分页地作业地址空间是维一地，即单一地线性空间，程序员只须利用一个记忆符，即可表示一地址. 
分段地作业地址空间是二维地，程序员在标识一个地址时，既需给出段名，又需给出段内地址.

memory manager 

1 段式存储管理
2 页式存储管理 
3 段页式存储管理  

虚拟地址空间和物理地址空间是独立的，32位处理器的虚拟地址空间是4GB，而物理地址空间既可以大于也可以小于4GB。
http://akaedu.github.io/book/ch17s04.html
32位处理器的页尺寸通常是4KB

通常操作系统把虚拟地址空间划分为用户空间和内核空间，
例如x86平台的Linux系统虚拟地址空间是 

    0x00000000~0xffffffff，
    前3GB（0x00000000~0xbfffffff）是用户空间，
    后1GB（0xc0000000~0xffffffff）是内核空间。
    
用户程序加载到用户空间，在用户模式下执行，不能访问内核中的数据，也不能跳转到内核代码中执行。
这样可以保护内核，如果一个进程访问了非法地址，顶多这一个进程崩溃，而不会影响到内核和整个系统的稳定性。
CPU在产生中断或异常时不仅会跳转到中断或异常服务程序，还会自动切换模式，从用户模式切换到特权模式，
因此从中断或异常服务程序可以跳转到内核代码中执行。事实上，整个内核就是由各种中断和异常处理程序组成的。

总结一下：在正常情况下处理器在用户模式执行用户程序，在中断或异常情况下处理器切换到特权模式执行内核程序，
处理完中断或异常之后再返回用户模式继续执行用户程序。


但是通过*pc只能访问到一个字节，而通过*pi可以访问到4个字节

you can full fix a box with water or air ,bu hard to fixed box full of gravels

box is a memory unit , gravel  is every bits value belong this unit 

