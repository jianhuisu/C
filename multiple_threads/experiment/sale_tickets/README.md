train tickets


在并发执行多进程时，当循环次数很大是，会产生进程间的切换，
        而多进程的切换可能导致在一个进程在对票数ticketCount进行操作后还未写回
        另外一个进程就读取该数据。产生读取脏数据及覆盖的问题，进而导致结果的不正确。
    在测试中，第2、3种情况是因改变两个进程循环次数而得到不同的值，这个值没有一定的规律。
        第4种情况是在售票后未及时写回，售票进程会在之后一段时间出现覆盖性写入。
        故而售票量多，剩余票结果较小。第5种情况是在退票后未及时写回，退票进程会在之后一段时间出现覆盖性写入。
        故而退票量多，剩余票结果较大。
        第6种情况加入了信号量就可保证售票进程和退票进程的的原子性，
        避免了脏数据读取和覆盖性写入等问题，结果正确，可保证进程同步。

作用：

主动释放CPU从而让另外一个线程运行
与sleep()的区别：

pthread_yield()函数可以使用另一个级别等于或高于当前线程的线程先运行。如果没有符合条件的线程，那么这个函数将会立刻返回然后继续执行当前线程的程序。
sleep()则函数是等待一定时间后等待CPU的调度，然后去获得CPU资源。

作者：Yolanda_gxy
链接：https://www.jianshu.com/p/9e5a1398b293
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


打开有名信号量 当打开一个一定存在的有名信号量时，ofalg设置为0.

    sem_t  *sem_open(const char *name, int oflag,..,/*mode_t mode,unsigned int value*/) 

一个进程终止时，内核对其上仍打开的所有有名信号量自动执行关闭操作。不论进程是自愿还是非自愿终止。

    int sem_close(sem_t *sem):关闭有名信号量

关闭一个信号量并没有将他从系统中删除。POSIX 有名信号量是随内核持续的：即使当前没有进程打开着某个信号量，他的值仍保持。

    int sem_unlink(const char *name):从系统中删除有名信号量

4.每个信号量有一个引用计数器记录打开的次数，当引用计数大于0时，name 就能从文件系统中删除，然而其信号量的析构（不同于将他的名字从文件系统中删除）却要等到最后一个sem_close发生时为止.

    sem_post
    
是给信号量的值加上一个“1”，它是一个“原子操作”－－－即同时对同一个信号量做加“1”操作的两个线程是不会冲突的；而同时对同一个文件进行读和写操作的两个程序就有可能会引起冲突。

    sem_wait(Sem);