## train tickets

在并发执行多进程时，当循环次数很大时，可能会产生线程间的切换，
而多线程的切换可能导致在一个线程在对票数ticketCount进行操作后还未写回(共用同一个地址空间)
另外一个进程就读取该数据。产生读取脏数据及覆盖的问题，进而导致结果的不正确。

    线程1 售票                   线程2 退票

    $t = $ticketCount
    $t -= 1;
    ...线程切换到thread_2...
                               $t = $ticketCount         
                               $t += 1;
                               $ticketCount = $t
    ...线程切换回 thread_1...                            
    $ticketCount = $t 
        
线程2对$ticketCount的+1操作被覆写,退票数未能及时记入总票数,程序统计剩余票数<=期望剩余票数
加入信号量可保证售票进程和退票进程的的原子性，避免幻读/覆盖性写入等问题，结果正确，可保证进程同步。

#### 信号量 semaphore 

    sem_t  *sem_open(const char *name, int oflag,..,/*mode_t mode,unsigned int value*/)
    
打开有名信号量 当打开一个一定存在的有名信号量时，ofalg设置为0.     

    int sem_close(sem_t *sem):

一个进程终止时，内核对其上仍打开的所有有名信号量自动执行关闭操作。不论进程是自愿还是非自愿终止。

    int sem_unlink(const char *name):
    
关闭一个信号量并没有将他从系统中删除。POSIX有名信号量是随内核持续的：即使当前没有进程打开着某个信号量，他的值仍保持。
每个信号量有一个引用计数器记录打开的次数，当引用计数大于0时,name 就能从文件系统中删除,
然而其信号量的析构（不同于将他的名字从文件系统中删除）却要等到最后一个sem_close发生时为止.
    
    sem_wait();
    
等待可用资源

    sem_post();
    
是给信号量的值加上一个“1”，它是一个“原子操作”－－－即同时对同一个信号量做+1操作的两个线程是不会冲突的
这部分操作使用操作系统的原语实现,原语不允许中断,是原子性操作

    