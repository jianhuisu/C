## 并发编程简述

编写正确的程序很难,而编程正确的并发程序则难上加难.与串行程序相比,并发程序存在更多容易出错的地方.
串行编程模型的优势在于其直观性以及简单性.因为这种模型符合人的工作方式.`每次只做一件事`.

线程的优势
 
 - 简化异步事件处理的复杂度.各种回调不利于理解维护.降低建模的复杂度.
 - 响应更加灵敏,避免在事件循环模型中因为某个事件的阻塞导致整个流程的冻结.
 - 发挥多处理器的优势.

线程的风险
	
 - 安全性问题
 - 性能问题 

### 例子

计数器 每处理一个请求将该值+1. 
	
	incr(num_counter)
	{
		return ++num_counter;
	}


该程序可以在单线程环境中正确运行,但是在多线程环境中,该函数可能会丢失一些更新操作.
`++num_counter`看上去是一种非常紧凑的语法,但是这个操作并非是原子性的,实际上它包含了三个独立的
操作.

 1. 取出num_counter的值
 1. 将值+1
 1. 将计算结果写回到num_counter

当两个线程同时读到该值为9,+1后回写为10.显然这不符合我们的期望.某些场景中丢失个别几个计数是可以接受的.
但是如果在要求数据强一致性的场景中,这种不正确结果的产生则是一种非常重要的场景,它有一个正式的名字:竟态条件(race condition)

>>竟态条件容易与数据竞争混淆.

最常见的竟态条件类型就是`check-then-act`操作.即通过一个可能失效的观测结果来决定下一步的动作.
比如当你迈出星巴克的前门时,你在星巴克的观察结果可能变的无效.你期望会面的朋友可能刚巧从后门进来.
`是否可以获得正确的结果,取决于事件发生的时序`.竟态条件可能会导致各种异常问题.数据覆盖,文件破坏等等.

注意与大多数并发错误一样,竟态条件的出现并不总是会引发错误，还需要不恰当的执行时序.

所以,为了避免竟态条件，我们需要将刚才的一组操作可以以原子方式执行.中间不允许打断.这样竟态条件就不会发生.(比如只允许在星巴克的前门出入). 我们将`check-then-act`统称为复合操作,包含了一组必须以原子方式执行的操作以确保线程的安全性.


### 原子性操作也有局限性

当需要维持的事物状态超过2个时,简单的原子性操作就不能满足我们的需求.这个时候我们需要`加锁`来维护事物的同时存在的`多个状态`.

### 参考资料

java并发编程实战 盖茨

