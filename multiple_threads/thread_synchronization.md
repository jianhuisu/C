## 线程同步

## 线程同步机制

 - Mutex 互斥锁 所有操作都互斥.一个`Condition Variable`总是和一个`Mutex`搭配使用.(Mutex可以单独使用 但是条件变量需要于Mutex搭配使用) 
   获得锁的线程可以完成“读-修改-写”的操作，然后释放锁给其它线程，没有获得锁的线程只能等待而不能访问共享数据，
   这样"读-修改-写"三步操作组成一个原子操作，要么都执行，要么都不执行，不会执行到中间被打断，也不会在其它处理器上并行做这个操作。
 - Reader-Writer Lock 读写锁 可以共享读,但是写是独占的,`Reader-Writer Lock`比`Mutex`具有更好的并发性
 - Semaphore 信号量 **信号量不仅可用于同一进程的线程间同步，也可用于不同进程间的同步**

用挂起等待的方式解决访问冲突不见得是最好的办法，因为这样毕竟会影响系统的并发性，在某些情况下解决访问冲突的问题可以尽量避免挂起某个线程.

#### 互斥量和信号量的区别 

 - 1. 互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。
 - 2. 互斥量值只能为0/1，信号量值可以为非负整数。
 - 3. 互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。

#### Mutex使用

Mutex的两个基本操作lock和unlock是如何实现的呢？假设Mutex变量的值为1表示互斥锁空闲，这时某个进程调用lock可以获得锁，而Mutex的值为0表示互斥锁已经被某个线程获得，其它线程再调用lock只能挂起等待。那么lock和unlock的伪代码如下：

    lock:
        if(mutex > 0){
            mutex = 0;
            return 0;
        } else
            挂起等待;
        goto lock;
    
    unlock:
        mutex = 1;
        唤醒等待Mutex的线程;
        return 0;
        
unlock操作中唤醒等待线程的步骤可以有不同的实现，可以只唤醒一个等待线程，也可以唤醒所有等待该Mutex的线程，然后让被唤醒的这些线程去竞争获得这个Mutex，竞争失败的线程继续挂起等待。

细心的读者应该已经看出问题了：对Mutex变量的读取、判断和修改不是原子操作。
如果两个线程同时调用lock，这时Mutex是1，两个线程都判断mutex>0成立，然后其中一个线程置mutex=0，而另一个线程并不知道这一情况，也置mutex=0，于是两个线程都以为自己获得了锁。

**为了实现互斥锁操作，大多数体系结构都提供了`swap`或`exchange`指令，该指令的作用是把寄存器和内存单元的数据相交换，
由于只有一条指令，保证了原子性，即使是多处理器平台，访问内存的总线周期也有先后(注释:CPU可以有多核,但是主存只能有一个)，
一个处理器上的交换指令执行时另一个处理器的交换指令只能等待总线周期。**
现在我们把lock和unlock的伪代码改一下（以x86的xchg指令为例）：

    lock:
        movb $0, %al
        xchgb %al, mutex
        if(al寄存器的内容 > 0){
            return 0;
        } else
            挂起等待;
        goto lock;
    
    unlock:
        movb $1, mutex
        唤醒等待Mutex的线程;
        return 0;
        
`unlock中`的释放锁操作同样只用一条指令实现，以保证它的原子性。

也许还有读者好奇，“挂起等待”和“唤醒等待线程”的操作如何实现？

每个Mutex有一个等待队列，一个线程要在Mutex上挂起等待，首先在把自己加入等待队列中，然后置线程状态为睡眠，然后调用调度器函数切换到别的线程。
一个线程要唤醒等待队列中的其它线程，只需从等待队列中取出一项，把它的状态从睡眠改为就绪，加入就绪队列，那么下次调度器函数执行时就有可能切换到被唤醒的线程。

#### DeadLock

 - 一般情况下，如果同一个线程先后两次调用lock，在第二次调用时，由于锁已经被占用，该线程会挂起等待别的线程释放锁，然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁，因此就永远处于挂起等待状态了，这叫做死锁（Deadlock）
 - 线程A获得了锁1，线程B获得了锁2，这时线程A调用lock试图获得锁2，结果是需要挂起等待线程B释放锁2，而这时线程B也调用lock试图获得锁1，结果是需要挂起等待线程A释放锁1，于是线程A和B都永远处于挂起状态了。

写程序时应该尽量避免同时获得多个锁，如果一定有必要这么做，则有一个原则：如果所有线程在需要多个锁时都按相同的先后顺序（常见的是按Mutex变量的地址顺序）获得锁，则不会出现死锁。
如果要为所有的锁确定一个先后顺序比较困难，则应该尽量使用pthread_mutex_trylock调用代替pthread_mutex_lock调用，以免死锁。

#### 信号量

    #include <semaphore.h>
    
    sem_t sem;
    
    sem_init(&sem,0,0);
    sem_post(&sem);
    sem_wait(&sem);
    sem_trywait(&sem);
    sem_destroy(&sem);
    
 

