## 线程同步

互斥锁：只有一个bool类型的值，只允许2个线程进行排队；
信号量：允许多个线程共同等待一个共享资源

四种进程或线程同步互斥的控制方法

1、临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。

    虽然临界区同步速度很快，但却只能用来同步同一进程内的线程，而不可用来同步多个进程中的线程。
    
2、互斥量 Mutex :为协调共同对一个共享资源的单独访问而设计的。

    因为使用互斥不仅仅能够在同一进程不同线程中实现资源的安全共享，而且可以在不同进程的线程之间实现对资源的安全共享。
    
    互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说它可以跨越进程使用。
    所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量 。
    因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。
    
3、信号量:为控制一个具有有限数量用户资源而设计。
    
    信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源 ，
    这与操作系统中的PV操作相同。它指出了同时访问共享 资源的线程 最大数目。
    它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。
    在用CreateSemaphore（）创建信号量 时即要同时指出允许的最大资源计数和当前可用资源计数。
    一般是将当前可用资源计数设置为最大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数 就会减1，
    只要当前可用资源计数是大于0的，就可以发出信号量信号。
    但是当前可用计数减小到0时则说明当前占用资源的线程数已经达到了所允许的最大数目， 不能在允许其他线程的进入，
    此时的信号量信号将无法发出。线程在处理完共享资源后，应在离开的同时通过ReleaseSemaphore（）函数将当前可 用资源计数加1。
    在任何时候当前可用资源计数决不可能大于最大资源计数。

4、事 件:用来通知线程有一些事件已发生，从而启动后继任务的开始。

    事件对象也可以通过通知操作的方式来保持线程的同步。并且可以实现不同进程中的线程同步操作。

#### 总结

总结：
1． 互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说它可以跨越进程使用。所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量 。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。
2． 互斥量（Mutex），信号灯（Semaphore），事件（Event）都可以被跨越进程使用来进行同步数据操作，而其他的对象与数据同步操作无关，但对于进程和线程来讲，如果进程和线程在运行状态则为无信号状态，在退出后为有信号状态。所以可以使用WaitForSingleObject来等待进程和 线程退出。
3． 通过互斥量可以指定资源被独占的方式使用，但如果有下面一种情况通过互斥量就无法处理，比如现在一位用户购买了一份三个并发访问许可的数据库系统，可以根据用户购买的访问许可数量来决定有多少个线程/进程能同时进行数据库操作，这时候如果利用互斥量就没有办法完成这个要求，信号灯对象可以说是一种资源计数器。

## 线程同步机制

 - Mutex 互斥锁 所有操作都互斥.一个`Condition Variable`总是和一个`Mutex`搭配使用.(Mutex可以单独使用 但是条件变量需要于Mutex搭配使用) 
   获得锁的线程可以完成“读-修改-写”的操作，然后释放锁给其它线程，没有获得锁的线程只能等待而不能访问共享数据，
   这样"读-修改-写"三步操作组成一个原子操作，要么都执行，要么都不执行，不会执行到中间被打断，也不会在其它处理器上并行做这个操作。
 - Reader-Writer Lock 读写锁 可以共享读,但是写是独占的,`Reader-Writer Lock`比`Mutex`具有更好的并发性
 - Semaphore 信号量 **信号量不仅可用于同一进程的线程间同步，也可用于不同进程间的同步**

用挂起等待的方式解决访问冲突不见得是最好的办法，因为这样毕竟会影响系统的并发性，在某些情况下解决访问冲突的问题可以尽量避免挂起某个线程.

#### 互斥量和信号量的区别 

 - 1. 互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。
 - 2. 互斥量值只能为0/1，信号量值可以为非负整数。
 - 3. 互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。

#### Mutex使用

Mutex的两个基本操作lock和unlock是如何实现的呢？假设Mutex变量的值为1表示互斥锁空闲，这时某个进程调用lock可以获得锁，而Mutex的值为0表示互斥锁已经被某个线程获得，其它线程再调用lock只能挂起等待。那么lock和unlock的伪代码如下：

    lock:
        if(mutex > 0){
            mutex = 0;
            return 0;
        } else
            挂起等待;
        goto lock;
    
    unlock:
        mutex = 1;
        唤醒等待Mutex的线程;
        return 0;
        
unlock操作中唤醒等待线程的步骤可以有不同的实现，可以只唤醒一个等待线程，也可以唤醒所有等待该Mutex的线程，然后让被唤醒的这些线程去竞争获得这个Mutex，竞争失败的线程继续挂起等待。

细心的读者应该已经看出问题了：对Mutex变量的读取、判断和修改不是原子操作。
如果两个线程同时调用lock，这时Mutex是1，两个线程都判断mutex>0成立，然后其中一个线程置mutex=0，而另一个线程并不知道这一情况，也置mutex=0，于是两个线程都以为自己获得了锁。

**为了实现互斥锁操作，大多数体系结构都提供了`swap`或`exchange`指令，该指令的作用是把寄存器和内存单元的数据相交换，
由于只有一条指令，保证了原子性，即使是多处理器平台，访问内存的总线周期也有先后(注释:CPU可以有多核,但是主存只能有一个)，
一个处理器上的交换指令执行时另一个处理器的交换指令只能等待总线周期。**


现在我们把lock和unlock的伪代码改一下（以x86的xchg指令为例）：

    lock:
        movb $0, %al
        xchgb %al, mutex
        if(al寄存器的内容 > 0){
            return 0;
        } else
            挂起等待;
        goto lock;
    
    unlock:
        movb $1, mutex
        唤醒等待Mutex的线程;
        return 0;
        
`unlock中`的释放锁操作同样只用一条指令实现，以保证它的原子性。

也许还有读者好奇，“挂起等待”和“唤醒等待线程”的操作如何实现？

每个Mutex有一个等待队列，一个线程要在Mutex上挂起等待，首先在把自己加入等待队列中，然后置线程状态为睡眠，然后调用调度器函数切换到别的线程。
一个线程要唤醒等待队列中的其它线程，只需从等待队列中取出一项，把它的状态从睡眠改为就绪，加入就绪队列，那么下次调度器函数执行时就有可能切换到被唤醒的线程。

#### DeadLock

 - 一般情况下，如果同一个线程先后两次调用lock，在第二次调用时，由于锁已经被占用，该线程会挂起等待别的线程释放锁，然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁，因此就永远处于挂起等待状态了，这叫做死锁（Deadlock）
 - 线程A获得了锁1，线程B获得了锁2，这时线程A调用lock试图获得锁2，结果是需要挂起等待线程B释放锁2，而这时线程B也调用lock试图获得锁1，结果是需要挂起等待线程A释放锁1，于是线程A和B都永远处于挂起状态了。

写程序时应该尽量避免同时获得多个锁，如果一定有必要这么做，则有一个原则：如果所有线程在需要多个锁时都按相同的先后顺序（常见的是按Mutex变量的地址顺序）获得锁，则不会出现死锁。
如果要为所有的锁确定一个先后顺序比较困难，则应该尽量使用pthread_mutex_trylock调用代替pthread_mutex_lock调用，以免死锁。
