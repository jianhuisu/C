## 线程同步机制比较

摘要:多线程同步技术是计算机软件开发的重要技术，本文对多线程的各种同步技术的原理和实现进行了初步探讨。
关键词:VC++6.0； 线程同步；临界区；事件；互斥；信号量；
(看样子这是一篇论文)

### 正文

使线程同步

在程序中使用多线程时，一般很少有多个线程能在其生命期内进行完全独立的操作。
更多的情况是一些线程进行某些处理操作，而其他的线程必须对其处理结果进行了解(即其它线程的决策依赖于处理结果).
正常情况下对这种处理结果的了解应当在其处理任务完成后进行。
如果不采取适当的措施，其他线程往往会在线程处理任务结束前就去访问处理结果，这就很有可能得到有关处理结果的错误了解。

例如，多个线程同时访问同一个全局变量，如果都是读取操作，则不会出现问题。
如果一个线程负责改变此全局变量的值，而其他线程负责同时读取全局变量内容，则不能绝对保证读取到的数据是经过写线程修改后的数据。

为了确保`读线程`读取到的是值经过修改后的值，就必须在向变量写入数据时禁止其他线程对其的任何访问，
直至赋值过程结束后再解除对其它线程的访问限制。像这种保证线程能了解其他线程任务处理结束后的处理结果而采取的保护措施即为线程同步。

线程同步是一个非常大的话题，包括方方面面的内容。从大的方面讲，线程的同步可分用户模式的线程同步和内核对象的线程同步两大类。

 - 用户模式中线程的同步方法主要有原子访问和临界区等方法。其特点是同步速度特别快，适合于对线程运行速度有严格要求的场合。
 - 内核对象的线程同步则主要由事件、等待定时器、信号量以及信号灯等内核对象构成。由于这种同步机制使用了内核对象，同步时必定会引起系统调用,一般要耗费近千个CPU周期，因此同步速度较慢，但在适用性上却要远优于用户模式的线程同步方式。

#### 临界区

临界区（Critical Section）是一段独占对某些共享资源访问的代码，在任意时刻只允许一个线程对共享资源进行访问。
如果有多个线程试图同时访问临界区，那么在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。
临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操作共享资源的目的.

临界区在使用时以`CRITICAL_SECTION`结构对象保护共享资源，并分别用`EnterCriticalSection()`和`LeaveCriticalSection()`函数去标识和释放一个临界区。
所用到的`CRITICAL_SECTION`结构对象必须经过`InitializeCriticalSection()`的初始化后才能使用，
而且必须确保所有线程中的任何试图访问此共享资源的代码都处在此临界区的保护之下,否则临界区将不会起到应有的作用，共享资源依然有被破坏的可能。
(大家都从门口走,管理员可以安排限流排队,大家都不从门口走,就无法有效管理)

    图1 使用临界区保持线程同步

下面通过一段代码展示了临界区在保护多线程访问的共享资源中的作用。
通过两个线程来分别对全局变量`g_cArray[10]`进行写入操作，用临界区结构对象`g_cs`来保持线程的同步，并在开启线程前对其进行初始化。
为了使实验效果更加明显，体现出临界区的作用，在线程函数对共享资源`g_cArray[10]`的写入时，以`Sleep()`函数延迟1毫秒，使其他线程同其抢占CPU的可能性增大。
如果不使用临界区对其进行保护，则共享资源数据将被破坏(结果不受控制)，而使用临界区对线程保持同步后则可以得到正确的结果(符合我们的期望结果)。代码实现清单附下：

    // 临界区结构对象
    CRITICAL_SECTION g_cs;
    // 共享资源
    char g_cArray[10];
    
    UINT ThreadProc10(LPVOID pParam)
    {
        // 进入临界区
        EnterCriticalSection(&g_cs);
        
        // 对共享资源进行写入操作    
        for (int i = 0; i < 10; i++)
        {
            g_cArray[i] = 'a';
            Sleep(1);
        }
    
        // 离开临界区
        LeaveCriticalSection(&g_cs);
        return 0;
    }
    
    UINT ThreadProc11(LPVOID pParam)
    {
    
        // 进入临界区
        EnterCriticalSection(&g_cs);
        
        // 对共享资源进行写入操作
        for (int i = 0; i < 10; i++)
        {
            g_cArray[10 - i - 1] = 'b';
            Sleep(1);
        }
        
        // 离开临界区
        LeaveCriticalSection(&g_cs);
        return 0;
    }
       
    void CSample08View::OnCriticalSection()
    {
        // 初始化临界区
        InitializeCriticalSection(&g_cs);
         
        // 启动线程
        AfxBeginThread(ThreadProc10, NULL);
        AfxBeginThread(ThreadProc11, NULL);
        
        // 等待计算完毕
        Sleep(300);
        
        // 报告计算结果
        CString sResult = CString(g_cArray);
        AfxMessageBox(sResult);
        
    }

在使用临界区时，一般不允许其运行时间过长，只要进入临界区的线程还没有离开，其他所有试图进入此临界区的线程都会被挂起而进入到等待状态，
并会在一定程度上影响程序的运行性能。尤其需要注意的是不要将等待用户输入或是其他一些外界干预的操作包含到临界区。
如果进入了临界区却一直没有释放，同样也会引起其他线程的长时间等待。

**虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程。**

#### 管理事件内核对象

在前面讲述线程通信时曾使用过事件内核对象来进行线程间的通信，除此之外，事件内核对象也可以通过通知操作的方式来保持线程的同步。
对于前面那段使用临界区保持线程同步的代码可用事件对象的线程同步方法改写如下：

    // 事件句柄
    HANDLE hEvent = NULL;
    // 共享资源
    char g_cArray[10];
    
    UINT ThreadProc12(LPVOID pParam)
    {
        // 等待事件置位
        WaitForSingleObject(hEvent, INFINITE);
        
        // 对共享资源进行写入操作
        for (int i = 0; i < 10; i++)
        {
            g_cArray[i] = 'a';
            Sleep(1);
        }
        
        // 处理完成后即将事件对象置位
        SetEvent(hEvent);
        return 0;
    }
    
    UINT ThreadProc13(LPVOID pParam)
    {
        // 等待事件置位
        WaitForSingleObject(hEvent, INFINITE);
        
        // 对共享资源进行写入操作
        for (int i = 0; i < 10; i++)
        {
            g_cArray[i] = 'a';
            Sleep(1);
        }
        
        // 处理完成后即将事件对象置位
        SetEvent(hEvent);
        return 0;
    }
        
    void CSample08View::OnEvent()
    {
        // 创建事件
        hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        // 事件置位
        SetEvent(hEvent);
        
        // 启动线程
        AfxBeginThread(ThreadProc12, NULL);
        AfxBeginThread(ThreadProc13, NULL);
        
        // 等待计算完毕
        Sleep(300);
        
        // 报告计算结果
        CString sResult = CString(g_cArray);
        AfxMessageBox(sResult);
        
    }

在创建线程前，首先创建一个可以自动复位的事件内核对象`hEvent`，而线程函数则通过`WaitForSingleObject()`等待函数无限等待`hEvent`的置位，
只有在事件置位时`WaitForSingleObject()`才会返回，被保护的代码将得以执行。
对于以自动复位方式创建的事件对象，在其置位后一被`WaitForSingleObject()`等待到就会立即复位，
也就是说在执行`ThreadProc12()`中的受保护代码时，事件对象已经是复位状态的，这时即使有`ThreadProc13()`对CPU的抢占，
也会由于`WaitForSingleObject()`没有`hEvent`的置位而不能继续执行，也就没有可能破坏受保护的共享资源。
在`ThreadProc12()`中的处理完成后可以通过`SetEvent()`对`hEvent`的置位而允许`ThreadProc13()`对共享资源`g_cArray`的处理。
这里`SetEvent()`所起的作用可以看作是对某项特定任务完成的通知。

使用临界区只能同步同一进程中的线程，而使用事件内核对象则可以对进程外的线程进行同步，
其前提是得到对此事件对象的访问权。可以通过`OpenEvent()`函数获取得到，其函数原型为：

    HANDLE OpenEvent(
        DWORD dwDesiredAccess, // 访问标志
        BOOL bInheritHandle, // 继承标志
        LPCTSTR lpName // 指向事件对象名的指针
    );

　　如果事件对象已创建（在创建事件时需要指定事件名），函数将返回指定事件的句柄。对于那些在创建事件时没有指定事件名的事件内核对象，可以通过使用内核对象的继承性或是调用DuplicateHandle()函数来调用CreateEvent()以获得对指定事件对象的访问权。在获取到访问权后所进行的同步操作与在同一个进程中所进行的线程同步操作是一样的。

　　如果需要在一个线程中等待多个事件，则用WaitForMultipleObjects()来等待。WaitForMultipleObjects()与WaitForSingleObject()类似，同时监视位于句柄数组中的所有句柄。这些被监视对象的句柄享有平等的优先权，任何一个句柄都不可能比其他句柄具有更高的优先权。WaitForMultipleObjects()的函数原型为：



#### 信号量内核对象

信号量（Semaphore）内核对象对线程的同步方式与前面几种方法不同，它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。
在用`CreateSemaphore()`创建信号量时即要同时指出允许的最大资源计数和当前可用资源计数。
一般是将当前可用资源计数设置为最大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就会减1，只要当前可用资源计数是大于0的，就可以发出信号量信号。
但是当前可用计数减小到0时则说明当前占用资源的线程数已经达到了所允许的最大数目，不能在允许其他线程的进入，此时的信号量信号将无法发出。
线程在处理完共享资源后，应在离开的同时通过`ReleaseSemaphore()`函数将当前可用资源计数加1。
在任何时候当前可用资源计数决不可能大于最大资源计数。


上述代码在开启线程前首先创建了一个初始计数和最大资源计数均为2的信号量对象hSemaphore。
即在同一时刻只允许2个线程进入由hSemaphore保护的共享资源。
随后开启的三个线程均试图访问此共享资源，在前两个线程试图访问共享资源时，由于hSemaphore的当前可用资源计数分别为2和1，此时的hSemaphore是可以得到通知的，
也就是说位于线程入口处的WaitForSingleObject()将立即返回，而在前两个线程进入到保护区域后，hSemaphore的当前资源计数减少到0，
hSemaphore将不再得到通知，WaitForSingleObject()将线程挂起。直到此前进入到保护区的线程退出后才能得以进入。
从实验结果可以看出，信号量始终保持了同一时刻不超过2个线程的进入。


#### 互斥内核对象

互斥（Mutex）是一种用途非常广泛的内核对象。能够保证多个线程对同一共享资源的互斥访问。
同临界区有些类似，只有拥有互斥对象的线程才具有访问资源的权限，由于互斥对象只有一个，因此就决定了任何情况下此共享资源都不会同时被多个线程所访问。
当前占据资源的线程在任务处理完后应将拥有的互斥对象交出，以便其他线程在获得后得以访问资源。
与其他几种内核对象不同，互斥对象在操作系统中拥有特殊代码，并由操作系统来管理，操作系统甚至还允许其进行一些其他内核对象所不能进行的非常规操作。

#### 小结

线程的使用使程序处理更够更加灵活，而这种灵活同样也会带来各种不确定性的可能。
尤其是在多个线程对同一公共变量进行访问时。
虽然未使用线程同步的程序代码在逻辑上或许没有什么问题，但为了确保程序的正确、可靠运行，必须在适当的场合采取线程同步措施。

#### 参考资料

原文地址 http://www.cppblog.com/killsound/archive/2009/07/15/16147.html