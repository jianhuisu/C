## 并发编程模型

##### 并发编程模型 `CSP` `Actor`

`CSP` `Actor` 是两种并发编程模型.

目前家用PC四核已经非常常见，服务器更是达到32核64线程。为了高效的利用多核CPU，应该在代码层面就考虑并发性。
经过十几年痛苦的开发经历，**事实告诉我们线程并不是获取并发性的最好方法，而往往会带来难以查找的问题**。

假设有两个线程并发地调整计数器，若计数器目前为10， 线程1要想计数器递减2，线程2想要计数器递减9，线程1和线程2都会检查当前计数器的值，而计数器的值均大于要递减的数量。
所以线程1和线程2都会继续运行并递减计数器的值，最后的结果是多少呢？10-2-9=-1，问题来了。这样的结果直接操作库存被过度分配，违反了业务规则。
为了防止过度分配，原生的方式是将检查和递减两步操作放到一个原子操作中，将两步操作锁定到一个操作中，就能够消除过度分配的可能性。

例如，两个线程同时尝试购买最后一件商品时，如果没有锁就可能出现多个线程同时断定计数器的值大于或等于购买数量，然后错误地递减计数器，从而导致出现负数。
然而，问题的根源在于一个请求对应一个线程。

另外，在高度竞争的阶段，很有可能出现很长的线程队列，他们都在等待递减计数器。但使用队列的方式的问题在于可能造成众多阻塞线程，也就是每个线程都在等待轮到它们去执行一个序列化的操作。
所以，应用设计者一不小心，内在的复杂性就有可能将多核多线程的应用变成单线程的应用，或者导致工作线程之间存在高度竞争。

并发性中的一致性和隔离性，一致性是让数据保持一致，例如银行转账的场景中，**转账完成时双方账户必须是一方减少一方增加**。
而隔离性而可以理解为牺牲一部分一致性需求，从而获得性能的提升。例如，在完全一致性的情况下，任务是串行的，此时也就不存在隔离性了。

一般而言，有两种策略用来在并发线程中进行通信：

 - 共享数据  共享数据的并发编程面临的最大问题是数据条件竞争`data race`，处理各种锁的问题是让人十分头疼的。(传统的并发编程模型采用这种方式)
 - 消息传递  消息传递机制和共享数据方式相比最大的优势在于不会产生数据竞争状态。

而实现消息传递有两种常见类型：

 - 基于channel的消息传递  CSP  描述两个的ulinix并发的实体通过共享的通讯管道（channel)进行通信的 并发模型。在该模型中，`channel`是比较重要的对象，它并不关注发送消息的实体，而只关心与发送消息时实体使用的channel
 - 基于Actor的消息传递。  Actor  
 
这两者是十分相近的概念，它们都着眼于消息传递，而且都使用了 channel/mailbox 这样的信道(队列)和 Actor/goroutine 这样的执行实体。
只不过 Actor 模型将执行实体和 mailbox 进行了耦合，一个 Actor 用一个 mailbox；而 CSP 则可以绑定多个 channel(类似发布者/订阅者模型)，Actor模型适用于对一致性需求不是很高且对性能需求较高的场景

##### 参考资料

https://www.jianshu.com/p/d803e2a7de8e
