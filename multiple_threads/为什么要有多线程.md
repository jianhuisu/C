## 为什么我们需要多线程

当遇到`IO`操作时,程序停止运行,等待`IO`操作完成.此时`CPU`闲置(`IO`与`CPU`属于两个独立电路,操作可以独立运行).
为了充分利用`CPU`的闲置时间.我们提出了多线程的概念,当一个线程因为`IO`阻塞时,我们可以出让`CPU`给另外一个线程使用.尽量避免`CPU`空转.

#### 为什么redis要采用单线程的实现方式呢？

redis是一个单线程的应用,为什么在多线程技术如此流行的今天,redis要采用单线程的实现方式呢？

redis的绝大部分操作都是完全基于内存的,所以当它操作数据时`几乎`是不需要等待的.(相对于从磁盘读取数据而言).
这意味着线程不需要读盘,不需要阻塞,CPU不会空转.既然不需要阻塞,那么也就不需要多线程了.没有多线程,自然也就节省下了线程调度及资源竞争的系统开销.
另外上面说到**操作数据时`几乎`是不需要等待的**,我们知道`IO`不仅仅有`磁盘IO`,也涉及到`网络IO`.网络IO也很耗时,也需要等待.这个时候单线程不就会阻塞了吗?
redis为了节省网络IO带来的开销.采用了`多路IO复用`的IO模型.**单单使用一个线程就可以同时监听成千上万个网络链接**(通常只有几百上千个TCP连接是活跃的).
Redis服务采用Reactor的方式来实现文件事件处理器（每一个网络连接其实都对应一个文件描述符,文件事件处理器使用`I/O`多路复用模块同时监听多个FD，
当 `accept`、`read`、`write` 和 `close` 文件事件产生时，文件事件处理器就会回调FD绑定的事件处理器。
虽然整个文件事件处理器是在单线程上运行的，但是通过`I/O`多路复用模块的引入，实现了同时对多个`FD`读写的监控，保障了网络通信的性能.

`redis`的单线程是指处理客户端请求读写数据采用单线程模型,而数据持久化,`rehash`这些非主线操作都是另外起一个线程.

总结来说,`redis`不使用多线程是因为它的两大特点`操作基于内存+多路IO复用`.另外从目前情况而言,`网络带宽`是目前影响redis吞吐量的最大瓶颈,接下来才可能是`CPU`.


#### 当别人问你redis为什么这么快时,可以按如下方式回答

