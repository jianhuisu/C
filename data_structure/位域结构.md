## 位域结构

有些信息在存储时，并不需要占用一个完整的字节， 而只需占一个或几个二进制位。
例如在存放一个开关量时，只有`0`和`1`两种状态， 用一位二进位即可。
为了节省存储空间，并使处理简便，C语言又提供了一种数据结构，称为“位域”或“位段”。
所谓“位域”是把一个字节中的二进位划分为几个不同的区域， 并说明每个区域的位数。
每个域有一个域名，允许在程序中按域名进行操作。
这样就可以用一个字节中的二进制位域来表示多个不同的对象。


#### 位域的定义和位域变量的说明位域定义与结构定义相仿，其形式为： 

    struct 位域结构名 
    {
    
     位域列表
    
    };
    
**其中位域列表的形式为**：

    类型说明符 位域名：位域长度
    
位域变量的说明与结构变量说明的方式相同。 可采用先定义后说明，同时定义说明或者直接说明这三种方式。例如：

    struct bs
    {
    　　int a:8;
    　　int b:2;
    　　int c:6;
    }data;
     
说明`data`为`struct bs`变量，位域变量共占两个字节。其中位域`a`占`8`位，位域`b`占`2`位，位域`c`占`6`位。

对于位域的定义尚有以下几点说明：

>Tips.1 一个位域必须存储在同一个字节中，不能跨两个字节。如一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。

例如：

    struct bs
    {
        unsigned a:4
        unsigned b:5 /*从下一单元开始存放*/
        unsigned c:4
    }
    
>Tips.2 由于位域不允许跨两个字节，因此单个位域的长度不能大于一个字节的长度.

当一个字节8位时,单个位域的长度不能超过8.

>Tips.3 位域可以无位域名，这时它只用来作填充或调整位置。无名的位域是不能使用的。

>例如：

    struct k
    {
        int a:1
        int :2 /*无位域名,该2位不能使用*/
        int b:3
        int c:2
    };
     
#### 位域的使用

下面例子是参加一个公司（白领科技-青岛）的笔试遇到的，当时做错了，为了怕忘了，赶紧写下来。

    1 #include <iostream>
    2 #include <memory.h>
    3 using namespace std;
    4 struct A
    5 {
    6     int a:5;
    7     int b:3;
    8 };
    9 int main(void)
    10 {
    11     char str[100] = "0134324324afsadfsdlfjlsdjfl";
    12     struct A d;
    13     memcpy(&d, str, sizeof(A));
    14     cout << d.a << endl;
    15     cout << d.b << endl;
    16     return 0;
    17 }
    
在32位x86机器上输出：

    $ ./langxun.exe
    -16
    1
    
解析：在默认情况下，为了方便对结构体内元素的访问和管理，当结构体内的元素长度都小于处理器的位数的时候，
便以结构体里面最长的元素为对齐单位，即结构体的长度一定是最长的数据元素的整数倍；
如果有结构体内存长度大于处理器位数的元素，那么就以处理器的位数为对齐单元。
由于是32位处理器，而且结构体中`a`和`b`元素类型均为`int`（也是4个字节），所以结构体的`A`占用内存为`4个字节`。

上例程序中定义了位域结构A，两个个位域为a占用5位，b占用3位，所以a和b总共占用了结构A一个字节,并且是低位的一个字节。

当程序运行到14行时，d内存分配情况：

    高位 00110100  00110011   00110001    00110000 低位
          '4'       '3'        '1'          '0'
            
其中`d.a`和`d.b`占用d低位一个字节`00110000`,`d.a : 10000`, `d.b : 001`
**`d.a`内存中二进制表示为`10000`，由于`d.a`为有符号的整型变量，输出时要对符号位进行扩展**，所以结果为`-16`二进制为`11111111111111111111111111110000`.
`d.b`内存中二进制表示为`001`，由于`d.b`为有符号的整型变量，输出时要对符号位进行扩展，所以结果为`1`二进制为`00000000000000000000000000000001`.

#### 位域的对齐

如果结构体中含有位域`bit-field`，那么VC中准则是：

 1. 如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；
 1. 如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；
 1. 如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式（不同位域字段存放在不同的位域类型字节中），Dev-C++和GCC都采取压缩方式；

系统会先为结构体成员按照对齐方式分配空间和填塞（padding）,然后对变量进行位域操作。

#### 参考资料

原文地址 https://www.cnblogs.com/bigrabbit/archive/2012/09/20/2695543.html