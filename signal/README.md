## 信号

1 用户输入命令，在Shell下启动一个前台进程。

2 用户按下Ctrl-C，这个键盘输入产生一个硬件中断。

3 如果CPU当前正在执行这个进程的代码，则该进程的用户空间代码暂停执行，CPU从用户态切换到内核态处理硬件中断。

4 终端驱动程序将Ctrl-C解释成一个SIGINT信号，记在该进程的PCB中（也可以说发送了一个SIGINT信号给该进程）。

5 当某个时刻要从内核返回到该进程的用户空间代码继续执行之前，**首先处理PCB中记录的信号**，发现有一个SIGINT信号待处理，而这个信号的默认处理动作是终止进程，
  所以直接终止进程而不再返回它的用户空间代码执行。(有时,用户进程提前注册了信号处理函数,内核在发现待处理信号时,切换到用户空间对该信号进行处理,这种方式称为Catch一个信号)
  
信号的三种处理方式:
  
忽略此信号。
执行该信号的默认处理动作
提供一个信号处理函数，要求内核在处理该信号时切换到用户态执行这个处理函数，这种方式称为捕捉（Catch）一个信号


默认是不允许产生core文件的，因为core文件中可能包含用户密码等敏感信息，不安全。

首先用ulimit命令改变Shell进程的Resource Limit，允许core文件**最大**为1024K：
$ ulimit -c 1024

ctrl + \ => SIGQUIT 终止进程并产生Core dump
ctrl + c => SIGINT 终止进程


sigset_t类型对于每种信号用一个bit表示“有效”或“无效”状态，至于这个类型内部如何存储这些bit则依赖于系统实现，
从使用者的角度是不必关心的，使用者只能调用以下函数来操作sigset_t变量，而不应该对它的内部数据做任何解释，比如用printf直接打印sigset_t变量是没有意义的。

如果信号的处理动作是用户自定义函数，在信号递达时就调用这个函数，这称为捕捉信号。

以上我们讨论了信号产生（Generation）的各种原因，
而实际执行信号的处理动作称为信号递达（Delivery），
信号从产生到递达之间的状态，称为信号未决（Pending）。
进程可以选择阻塞（Block）某个信号。被阻塞的信号产生时将保持在未决状态，直到进程解除对此信号的阻塞，才执行递达的动作。
注意，阻塞和忽略是不同的，只要信号被阻塞就不会递达，而忽略是在递达之后可选的一种处理动作。

如果信号的处理动作是用户自定义函数，在信号递达时就调用这个函数，这称为捕捉信号。

信号捕捉后续处理流程

用户程序注册了SIGQUIT信号的处理函数sighandler。
当前正在执行main函数，这时发生中断或异常切换到内核态。
在中断处理完毕后要返回用户态的main函数之前检查到有信号SIGQUIT递达。
内核决定返回用户态后不是恢复main函数的上下文继续执行，而是执行sighandler函数，**sighandler和main函数使用不同的堆栈空间，它们之间不存在调用和被调用的关系，是两个独立的控制流程。**
sighandler函数返回后自动执行特殊的系统调用sigreturn再次进入内核态。
如果没有新的信号要递达，这次再返回用户态就是恢复main函数的上下文继续执行了。

######33 下一节线程会讲到如何保证一个代码段以原子操作完成。

### 可重入函数

当捕捉到信号时，不论进程的主控制流程当前执行到哪儿，都会先跳到信号处理函数中执行，从信号处理函数返回后再继续执行主控制流程。
信号处理函数是一个单独的控制流程，因为它和主控制流程是异步的，二者不存在调用和被调用的关系，并且使用不同的堆栈空间。
引入了信号处理函数使得一个进程具有多个控制流程，如果这些控制流程访问相同的全局资源（全局变量、硬件资源等），就有可能出现冲突

如果一个函数符合以下条件之一则是不可重入的：

 - 调用了malloc或free，因为malloc也是用全局链表来管理堆的。
 - 调用了标准I/O库函数。标准I/O库的很多实现都以不可重入的方式使用全局数据结构。
 
如果一个函数只访问自己的局部变量或参数，则称为可重入（Reentrant）函数。

在上面的例子中，main和sighandler都调用insert函数则有可能出现链表的错乱，
其根本原因在于，**对全局链表的插入操作要分两步完成，不是一个原子操作，假如这两步操作必定会一起做完，中间不可能被打断，就不会出现错乱了**。

#### 竟态条件

出现这个问题的根本原因是系统运行的时序（Timing）并不像我们写程序时所设想的那样。虽然alarm(nsecs)紧接着的下一行就是pause()，但是无法保证pause()一定会在调用alarm(nsecs)之后的nsecs秒之内被调用。由于异步事件在任何时候都有可能发生（这里的异步事件指出现更高优先级的进程），如果我们写程序时考虑不周密，就可能由于时序问题而导致错误，这叫做竞态条件（Race Condition）。


### 参考资料

https://docs.huihoo.com/c/linux-c-programming/ch33s04.html