### 注意事项

-阻塞是相对于进程的，不是阻塞操作系统
-对I/O的分析是从不同维度的,不同维度不要混为一谈
-操作系统本身是一个超大的程序，操作系统衍生出 进程/内核 的概念，目的是便于我们理解学习
-内核缓冲区与进程缓冲区
-缓冲与缓存不是一个概念[buffer 与 cache]

### 用户进程缓冲区

用户进程通过系统调用访问系统资源的时候，需要切换到内核态，而这对应一些特殊的堆栈和内存环境，
必须在系统调用前建立好。而在系统调用结束后，cpu会从核心模式切回到用户模式，而堆栈又必须恢复成用户进程的上下文。
而这种切换就会有大量的耗时。

你看一些程序在读取文件时，会先申请一块内存数组，称为buffer，然后每次调用read，读取设定字节长度的数据，
写入buffer。（用较小的次数填满buffer）。之后的程序都是从buffer中获取数据，当buffer使用完后，在进行下一次调用，填充buffer。

所以说：用户缓冲区的目的是为了减少系统调用次数，从而降低操作系统在用户态与核心态切换所耗费的时间。

### 内核缓冲区

除了在进程中设计缓冲区，内核也有自己的缓冲区。

当一个用户进程要从磁盘读取数据时，内核一般不直接读磁盘，而是将内核缓冲区中的数据复制到进程缓冲区中。
但若是内核缓冲区中没有数据，内核会把对数据块的请求，加入到请求队列，然后把进程挂起，为其它进程提供服务。
等到数据已经读取到内核缓冲区时，把内核缓冲区中的数据读取到用户进程中，才会通知进程，
当然不同的io模型，在调度和使用内核缓冲区的方式上有所不同.

你可以认为，read是把数据从内核缓冲区复制到进程缓冲区。write是把进程缓冲区复制到内核缓冲区。
当然，write并不一定导致内核的写动作，比如`os可能会把内核缓冲区的数据积累到一定量后`，再写入磁盘或者发送到其它进程。这也就是为什么断电有时会导致数据丢失。

所以说内核缓冲区，是为了在OS级别，提高磁盘IO效率，优化磁盘写操作。


### 什么是I/O

-处理器cpu：cpu控制着一个程序的执行。
-输出输出IO：linux有句话叫“一切都是流”，也就是所有输入输出设备的数据，包括硬盘，内存，终端都可以像流一样操作。
-进程管理：类似对进程的创建，休眠，唤醒，释放之类的调度。比如linux下的fork和windows下的CreateProcess()函数。
-内存： 包括内存的申请，释放等管理操作。
-设备：这个就是常常说的外设了，比如鼠标，键盘。
-计时器：计算机能计时是因为晶体振荡器产生的电磁脉冲。那么所有的定时任务都是以它为基础的。
-进程间通信(IPC),进程之间是不能够互相访问内存的，所以进程与进程之间的交互需要通信，而通信也是一种资源。
-网络通信：网络通信可以看做是进程见通信的特殊形式。

上面所说的这些系统资源，在用户进程中是无法被直接访问的，只能通过操作系统来访问，所以也把操作系统提供的这些功能成为:“系统调用”。

### 一个I/O操作通常包括两个阶段：

- 等待内核将数据准备好
- 内核将数据从内核空间复制到进程空间

### I/O的维度分析

-模式【阻塞，非阻塞】
-监视套接字量级【单个,多个】

----------------------------------------------------------------------------

    阻塞式I/O    ：  进程发起对系统资源的调用,如果内核不能立即返回调用数据，内核主动冷冻该进程，在内核寻找数据期间，该进程会一直处于冷冻状态，即内核不会再为该进程分配CPU时间片，提高CPU使用率高
                    解冻后从发起调用处开始继续执行...
                    比如 recvfrom() 调用
    非阻塞式I/O   ： 进程发起对系统资源的调用,如果内核不能立即返回调用数据，内核会立即返回一个错误代码【错误代码实质为一个调用结果，表示没找到数据，】至该进程，进程代码继续向下执行
                    此时内核不会冷冻该进程，但是内核会将寻找进程所需数据的任务添加到待办事务列表中【一个队列】，然后按序处理事项... 当进程再次访问数据时返回真实数据而不是
                    进程中success分支中的代码只有在请求结果为真实数据时才会被触发
                    todo 这个重复查询由谁负责？ 系统调用函数本身还是用户进程的业务逻辑里？
                    这种写法会函数只会执行一次，更加倾向于对当时状态的查询 并不能确保获取到期望数据
                        if(no_block_request() ！== 内核错误码 ){
                            // success
                        } else {
                            // fail
                        }

                    这种写法可以不停请求直至正确结果返回
                    continue = true;
                    while(continue){
                        if(no_block_request() ！== 内核错误码 ){
                            // success
                            continue = false;
                        } else {
                            // fail
                            continue = true;
                        }
                    }

                    这种方式称为轮询（polling）
                    非阻塞I/O会占用部分或全部进程的CPU时间片来发起询问性[有没有返回...有没有返回]的系统调用,所以会降低CPU的使用率

    ---------------------------------------------------------
    同步I/O DIO 也成为直接I/O
        相当于发起一个阻塞的I/O请求，必须等待系统调用的返回结果，等待期间需要被挂起(就是被冷冻...)
    异步I/O  AIO
        应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。
        进程发起对系统资源的调用,如果内核不能立即返回调用数据，内核会立即返回一个返回码至该进程，
        进程收到返回码后代码继续向下执行,此时进程与内核分别执行以下操作
            进程：进程需要在进行系统调用之前就已经在内核注册好一个内核可以回调的函数地址，在内核准备好数据之后，内核会主动切换到用户态并调用该函数，
                 这一部分属于提前应该做的准备工作。然后回归正题，进程在收到系统调用返回码后,根据返回码继续向下执行。
            内核：内核将该数据查找任务加入对应的待办队列[不同的资源有不同的等待队列],内核在合适的时间开始按序处理该队列中的任务，每处理完一个任务，
                 会根据进程提前注册的回调函数主动通知进程。


#### I/O单用思想 监视单个套接字

    accept
    webServer单个进程处理多个I/O可以使用 accept配合多线程/多进程实现
    如果同时有几万个连接，那么就需要创建相同数量的线程。

#### I/O 复用思想,允许应用程序监视一组文件描述符

    内核实现的，
    select与accept是同一级别的API

#### I/O 复用思想的几种具体实现

    select : 基本所有平台都已支持
    poll   : 较新系统支持
    epoll  : linux 平台
    kqueue : macOS

select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。

- select 会修改描述符，而 poll 不会；
- select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；
- poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。
- select 和 poll 速度都比较慢，每次调用都需要将[全部描述符]从应用进程缓冲区复制到内核缓冲区。


### 参考资料

http://www.pulpcode.cn/2017/02/01/user-buffer-and-kernel-buffer/

https://github.com/CyC2018/CS-Notes

Unix网络编程