## 什么是tcp字节流协议

TCP协议是面向连接的、可靠的、基于字节流的传输层通信协议.
`TCP/IP`协议簇中的`TCP协议`能够保证数据段`Segment`的可靠性和顺序性，有了可靠的传输层协议之后，
应用层协议就可以直接使用TCP协议传输数据，不再需要关心数据段的`丢失`,`乱序`,`重复`等问题.
TCP协议解决的是传输的可靠性和顺序问题，上层(即应用层)不需要关心数据能否传输到目标进程，只要写入到TCP协议的缓冲区的数据，TCP协议栈负责保证数据的送达。

当应用层协议使用TCP协议传输数据时，TCP协议可能会将应用层发送的数据切割重组后顺序发送.而数据的接收方TCP协议栈中收到的数据段可能有多个`应用层数据包`组成，
**当接收方从TCP协议栈中读取数据时会发现不相关的数据出现在了同一个数据段中**，应用层需要对收到的数据段进行拆分。
注意:分割重组是来自不同应用的数据包在TCP协议发送缓存中头尾相连,不是交叉相连.
比如一个HTTP包长度为6,一个FTP包长度为10,他们在TCP发送缓冲区中组合方式可能为以下这种

    | http_1 | http_2 | http_3 | http_4 | http_5 | http_6 |  ftp_1 | ftp_2 | ftp_3 | ftp_4 | ftp_5 | ftp_6 | 到这里结束,进行发送
     
或者这种
     
    | ftp_1 | ftp_2 | ftp_3 | ftp_4 | ftp_5 | ftp_6 | ftp_7 | ftp_8 | ftp_9 | ftp_10 | http_1 | http_2 |  到这里结束,进行发送

但是绝对不会是下面这种交错在一起的

    | ftp_1 | http_1 | ftp_2 | ftp_3 | http_2 | ...

#### 为什么会产生粘包问题

应用层交给TCP协议的数据并不会以消息为单位向目的主机传输，这些来自于不同应用的小数据段在某些情况下会被组合成一个大数据段发送给目标的主机。
在早期的互联网中，Telnet是被广泛使用的应用程序，然而使用Telnet会产生大量只有1字节负载的有效数据，每个数据包都会有`40`字节的额外开销，带宽的利用率只有 ~2.44%.

`Nagle`算法是一种通过减少数据包的方式提高TCP传输性能的算法.
因为网络带宽有限,它不会将小的数据块直接发送到目的主机，而是会在本地缓冲区中等待更多待发送的数据，
**这种批量发送数据的策略虽然会影响实时性和网络延迟，但是能够降低网络拥堵的可能性并减少额外开销。**
当应用层协议通过`TCP`协议传输数据时，实际上待发送的数据先被写入了TCP协议的缓冲区，
如果用户开启了`Nagle`算法，那么 TCP 协议不会立刻发送写入的数据,它会等待缓冲区中数据超过最大数据段`MSS`或者上一个数据段被`ACK`时才会发送缓冲区中的数据。
(今天的网络带宽资源不再像过去那么紧张，在默认情况下，Linux内核都会使用如下的方式默认关闭 Nagle 算法,但是Nagle算法确实能够在数据包较小时提高网络带宽的利用率并减少TCP和IP协议头带来的额外开销，).

无论是`TCP_NODELAY`还是`TCP_CORK`，它们都会通过延迟发送数据来提高带宽的利用率，它们会对应用层协议写入的数据进行拆分和重组.
而这些机制和配置能够出现的最重要原因是**TCP协议是基于字节流的协议，其本身没有数据包的概念，不会按照数据包发送数据。**

##### 消息边界

如果我们能在应用层协议中定义消息的边界，那么无论 TCP 协议如何对应用层协议的数据包进程拆分和重组，
接收方都能根据协议的规则恢复对应的消息。在应用层协议中，最常见的两种解决方案就是**基于长度**或者**基于终结符`Delimiter`**.

基于长度的实现就是`固定包头 + 包体协议`,有两种方式

 - 使用固定长度，所有的应用层消息都使用统一的大小，
 - 使用不固定长度，但是需要在应用层协议的协议头中增加表示负载长度的字段，这样接收方才可以从字节流中分离出不同的消息，
 
`HTTP`协议的消息边界就是基于长度实现的：（消息头的长度是固定的,但是报文体的长度声明在报文头中）

    HTTP/1.1 200 OK
    Content-Type: text/html; charset=UTF-8
    Content-Length: 138
    ...
    Connection: close
    
    <html>
      <head>
        <title>An Example Page</title>
      </head>
      <body>
        <p>Hello World, this is a very simple HTML document.</p>
      </body>
    </html>
    
    
在上述 HTTP 消息中，我们使用`Content-Length`头表示`HTTP`消息的负载大小，当应用层协议解析到足够的字节数后，
就能从中分离出完整的HTTP消息，无论发送方如何处理对应的数据包，我们都可以遵循这一规则完成HTTP消息的重组。

#### 总结

粘包问题出现的核心原因：

 - `TCP`协议是基于字节流的传输层协议，其中不存在消息和数据包的概念.
 - 应用层协议没有使用基于长度或者基于`分割符`的消息边界，导致多个消息的粘连.

基于UDP协议的应用层协议应该如何设计？会出现粘包的问题么？

答:UDP不会出现粘包问题.

有哪些应用层协议使用基于长度的分帧？又有哪些使用基于终结符的分帧？

答:常见的TCP通用网络通信协议有 HTTP、HTTPS、FTP、SMTP、POP3、IMAP、SSH、Redis、Memcache、MySQL.

 - Memcache、FTP、SMTP 都使用 `\r\n` 作为结束符
 - HTTP、HTTPS 固定包长度方式.
 
流媒体播放通常使用UDP协议,UDP包可能出现乱序,重复等问题,为什么我们看视频不会错乱？
    
答:应用层对包进行部分缓冲，重组播放.应用层实现包的排序.
