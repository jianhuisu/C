## Linux 系统调用(本章超级重要 是理解性能优化的基础)

**系统调用函数不可能完全用C代码来写，因为任何C代码都不会编译生成int指令，**
所以这个函数有可能是完全用汇编写的，也可能是用C内联汇编写的，甚至可能是一个宏定义（省了参数入栈出栈的步骤）。
_exit函数也是如此，我们讲过这些系统调用的包装函数位于Man Page的第2个Section。
所以,系统调用是汇编完成目标文件,而不是常规的C程序.

`open`、`read`、`write`、`close`等`系统函数`称为`无缓冲I/O（Unbuffered I/O）函数`，因为它们位于C标准库的I/O缓冲区的底层。
用户程序在读写文件时既可以调用C`标准I/O`库函数，也可以直接调用底层的`Unbuffered I/O`函数.

注意:write也不一定是直接写到文件的，也可能写到内核I/O缓冲区中.

### 编写程序时如何选择调用`标准I/O` OR `Unbuffered I/O`

 - 用`Unbuffered I/O函数`每次读写都要进内核，**调一个系统调用比调一个用户空间的函数要慢很多**,所以在用户空间开辟`I/O缓冲区`还是必要的.
 - 用C标准I/O库函数就比较方便，省去了自己管理I/O缓冲区的麻烦.

### 使用平台限制
 
 - C标准I/O库函数在头文件`stdio.h`中声明,任何实现了C标准库的平台都可以引用.
 - `Unbuffered I/O函数`，，而`read`、`write`等函数在头文件`unistd.h`中声明，只有在Unix平台上可以使用.
 
##### 网络编程通常直接调用`Unbuffered I/O`函数

UNIX的传统是`Everything is a file`，I/O函数不仅用于读写常规文件，也用于读写设备，比如终端或网络设备。
**在读写设备时通常是不希望有缓冲的**，例如向代表网络设备的文件写数据就是希望数据通过网络设备发送出去，而不希望只写到缓冲区里就算完事儿了.
当网络设备接收到数据时应用程序也希望第一时间被通知到.

### 参考地址

http://akaedu.github.io/book/ch28s02.html