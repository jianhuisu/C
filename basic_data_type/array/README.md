## array

在定义数组int count[4];时，方括号（Bracket）中的数字4表示数组的长度.
访问数组时,count[i]表示从数组开头跳过`4*i`个字节之后的那个存储单元.比如count数组中的每个元素占4个字节，则count[i]表示从数组开头跳过`4*i`个字节之后的那个存储单元.

### 运算符的优先级

到目前为止我们学习了五种后缀运算符：

    后缀`++`、
    后缀`--`、
    结构体取成员`.`、
    数组取下标`[]` 、
    函数调用`()`

还学习了五种单目运算符（或者叫前缀运算符）：

    前缀++、
    前缀--、
    正号+、
    负号-、
    逻辑非!

**在C语言中后缀运算符的优先级最高，单目运算符的优先级仅次于后缀运算符，比其它运算符的优先级都高**,
所以`++count[2]`应该看作对`count[2]`做前缀++运算。

### 数组边界问题

使用数组下标不能超出数组的长度范围，这一点在使用变量做数组下标时尤其要注意。
C编译器并不检查count[-1]或是count[100]这样的访问越界错误，编译时能顺利通过，所以属于运行时错误。

### 数组的初始化

数组也可以像结构体一样初始化，未赋初值的元素也是用0来初始化

### 数组不能相互赋值或初始化，不能用数组类型作为函数的参数或返回值

数组类型做右值使用时，自动转换成指向数组首元素的指针

    a = b

这个表达式，a和b都是数组类型的变量，但是b做右值使用，自动转换成指针类型，而左边仍然是数组类型，
所以编译器报的错是error: incompatible types in assignment.

### rand 生成随机数

0-10

    void gen_random(int upper_bound)
    {
        int i;
        for (i = 0; i < N; i++)
            a[i] = rand() % upper_bound;
    }

10-20

    void gen_random(int upper_bound)
    {
        int i;
        for (i = 0; i < N; i++)
            a[i] = (rand() % upper_bound) + 10;
    }
