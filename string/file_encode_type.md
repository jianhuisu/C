## 文件编码

#### 一个问题引发的血案:如果遍历一个utf-8的文件,使用解析`ascii`字符的函数去解析里面的字符,会发生什么.

    [sujianhui@dev0529 linera]$>file 字符串面试题.md
    字符串面试题.md: UTF-8 Unicode text
    [sujianhui@dev0529 linera]$>vim 1.php
    [sujianhui@dev0529 linera]$>file 1.php 
    1.php: PHP script, ASCII text

#### ASCII编码

在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，
这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就可以表示256个符号，从0000000到11111111。
上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。

ASCII码一共规定了128个字符的编码，比如

 - 0-32表示的是控制码,空格"SPACE"码值为是32.
 - '0'的ASCII编码是48,如果一个字符为数字,用他的ASCII编码值减去48,就是它的整型值.
 - 大写的字母A是65
 - 小写的字符a是97

这128个符号（包括32个不能打印出来的控制符号），为什么256种组合只能表示128个字符而不是256个字符呢？
因为`ASCII`只占用了一个字节的后面7位，最前面的1(最左边的一位)位统一规定为0。

#### unicode

世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。
为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。
可以想象，如果有一种编码，将世界上所有的符号都纳入其中。
每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码。

从UNICODE开始，无论是半角的英文字母，还是全角的汉字，它们都是统一被称呼为"一个字符"!
同时，也都是统一称呼为的"占用两个字节表示"，请注意"字符"和"字节"两个术语的不同，
"字节"是一个8位的物理存贮单元，而"字符"则是一个文化相关的符号。在UNICODE中，一个字符就是两个字节。

UNICODE是用两个字节来表示为一个字符，他总共可以组合出65535不同的字符，这大概已经可以覆盖世界上所有文化的符号。
如果还不够也没有关系，ISO已经准备了UCS-4方案，说简单了就是四个字节来表示一个字符，这样我们就可以组合出21亿个不同的字符出来（最高位有其他用途），
这大概可以用到银河联邦成立那一天吧！

!!!经过无数的历史证明,标准化是提升效率的前提,是自动化的基础.秦始皇 书同文 车同轨 是多么的伟大.

#### Unicode的问题

需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。
意思就是,只规定了逻辑上该如何表示,但是没有规定在物理机上如何实现.因为物理机的架构可能不同,导致字节相关操作存在差异.

比如，汉字"严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。
表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。(银河联邦成立的先兆)

知识的进化引发了两个严重的问题，

 - Q1: 如何才能区别`unicode`和`ascii`？**计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢**？
 - Q2: 事实上,英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于空间来说是极大的浪费。

以上两个问题的存在,导致unicode在很长一段时间内无法推广，因为投入产出比比较低.直到互联网的出现,互联网即将带来的巨大收益强烈促使人们寻求良好的解决方案:一种统一的编码方式.
**UTF-8就是在互联网上使用最广的一种unicode的实现方式**.其他实现方式还包括UTF-16和UTF-32，不过在互联网上基本不用。
**重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一**。

UTF-8最大的一个特点，就是它是一种**变长的编码方式**。它可以**使用1~4个字节表示一个符号**，根据不同的符号而变化字节长度。

UTF-8的编码规则很简单，只有二条：

 1. 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。(解决上面的Q2)
 1. 对于`n`字节的符号（`n>1`），第一个字节的前`n`位都设为`1`，第`n+1`位设为`0`，后面字节的前两位一律设为`10`。其余未提及的二进制位，全部用来存储这个符号的`unicode`码值.(用来解决上面的Q1)

没有例子理解不透彻,上demo.

         Unicode符号范围 | UTF-8编码方式
              (十六进制) | （二进制） 字母x表示可用编码的位
    --------------------+---------------------------------------------
    0000 0000-0000 007F | 0xxxxxxx
    0000 0080-0000 07FF | 110xxxxx 10xxxxxx
    0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
    0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

下面，还是以汉字"严”为例，演示如何实现UTF-8编码。

已知"严”的unicode是`4E25`二进制为`100111000100101`，根据上表，可以发现`4E25`处在第三行的范围内`0000 0800-0000 FFFF`，
因此"严”的UTF-8编码需要三个字节，即格式是`1110xxxx 10xxxxxx 10xxxxxx`。
然后，**从"严”的最后一个二进制位开始，依次从后向前填入格式中的`x`，多出的位补`0`**。
这样就得到了，"严”的UTF-8编码是`11100100 10111000 10100101`，转换成十六进制就是`E4B8A5`。

#### 文件遍码中的大端与小端

以汉字"严"为例子,他的unicode码为"4E25",如何按照UTF-8方式存储,那么需要三个字节.如果按照UCS-2格式直接存储,则需要两个字节.
我们以UCS-2方式存储为例子:

 1. 需要两个字节存储,分别表示`4E` 和 `25`.
 1. 即需要两个二进制的8位组来分别表示`4E` `25` 两个16进制数.

那么在存储时:

 - `4E`存储在前一个字节中，`25`在后一个字节中，就是`Big endian`方式
 - `25`在前一个字节中，`4E`在后一个字节中，就是`Little endian`方式

所以:
    
 - 大端小端概念存在与多字节遍码的场景中.
 - 单字节中只有高位低位,没有大端小端.

另外,因为大端或者小端表示法在各方面的表现难分高下,所以技术人员对其选择只能依靠自身的喜好来决定.
等到人们意识到需要统一时,因为已经推行一段时间,存在一定的历史包袱,所以目前来说两者还会共存一段时间.

那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？

Unicode规范中定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格“（ZERO WIDTH NO-BREAK SPACE），
用`FEFF`表示。这正好是两个字节，而且`FF`比`FE`大1。

 - 如果一个文本文件的头两个字节是`FE` `FF`，就表示该文件采用大头方式;
 - 如果头两个字节是`FF` `FE`，就表示该文件采用小头方式。

#### CPU中的大端与小端

有时候，用C语言写程序时需要知道是大端模式还是小端模式。 
所谓的大端模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；
所谓的小端模式，是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。

**为什么会有大小端模式之分呢？**

这是因为在计算机系统的CPU中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。
但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），
另外，对于位数大于8位的处理器，例如16位或者32位的处理器，**由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题**。
因此就导致了大端存储模式和小端存储模式。

例如一个16bit的short型变量x，占用两个内存单元表示,这两个内存单元地址依次为`0x0010`，`0x0011`.通常我们只需要提供首单元地址即可,内存单元连续分配,隐式包含在首单元地址中.
那么这两个地址中:

 - `0x0010` 低地址
 - `0x0011` 高地址

`x`的值为`0x1122`，(可以理解为十进制的数字`一千零五十`)那么

 - `0x11`为高字节，(十进制中的`一千`)
 - `0x22`为低字节，(十进制中的`零五十`)

对于不同的CPU,(主要是针对CPU里面的寄存器) 
 
 - 将高字节存储在低地址，就是`Big endian`方式 (因为地址是从低向高 增长的)
 - 将高字节存储在高地址，就是`little endian`方式
 
在常见的CPU架构中

 - 86结构是小端模式，
 - KEIL C51为大端模式。
 - ARM 小端模式 (有些ARM处理器还可以由硬件来选择是大端模式还是小端模式)
 - DSP 小端模式

#### 参考文献

原文链接：https://blog.csdn.net/lvxiangan/article/details/8151670
原文链接：https://blog.csdn.net/woxiaozhi/article/details/6891356