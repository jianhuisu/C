## 汇编语言要点
    
    vim section.s 
    as section.s -o section.o
    ld section.o -o sec

### 原理简介

在C语言中我们通过变量名访问一个变量，其操作目的实质为读写某个地址的内存单元，编译链接后,助记符都会被替换为内存地址.
我们通过函数名调用一个函数，其实就是跳转到该函数第一条指令所在的地址，
所以变量名和函数名都是符号，本质上是代表内存地址的.

 `char a = 3;` 假设助记符`a`代表的虚地址为`0x000000000ffa`，那么这个定义的意思就是：地址序号为`0x000000000ffa`的内存单元中存储的数据为`字符3`
 `char b = a;` 假设助记符`a`代表的虚地址为`0x000000000ffa`,`b`代表的虚地址为`0x000000000ffb`,这行赋值语句的意思就是:将地址序号为`0x000000000ffa`的内存单元中存储的数据`copy`一份到地址序号为`0x000000000ffb`的内存单元.

### 类型声明

 - `.long`指示声明一组数，每个数占32位，相当于C语言中的数组`.long 3,67,34,222,45,75,54,34,44,33,22,11,66,0`
 - `.byte`，也是声明一组数，每个数占8位
 - `.ascii`，例如.ascii "Hello world"，声明11个数，取值为相应字符的ASCII码。注意，和C语言不同，这样声明的字符串末尾是没有'\0'字符的，如果需要以'\0'结尾可以声明为.ascii "Hello world\0"。 
 
### 汇编代码书写要点

 1. 缩进没有严格要求,只要每个指令独占一行即可
 1. 指令末尾没有标点符号
 1. 必须写注释

### 寻址方式

 - 直接寻址       movl %eax, %ebx                内存寻址:把eax寄存器上存储的值A 传送到ebx寄存器 
 - 间接寻址       movl (%eax), %ebx              内存寻址:把eax寄存器的值A看作地址,找到这个地址A上值B,把值B传送到ebx寄存器. 
 - 变址寻址       movl data_items(,%edi,4), %eax 内存寻址: `data_items`表示数组首元素的地址,是一个`常数`，指令的意思是 从`data_items`开始计算，偏移 `%edi * 4` 个字节处的数据 发送到寄存器`%eax`上
 - 基址寻址       movl 4(%eax), %ebx             内存寻址:  每个成员占用4个字节,如果其中一个成员为`char`类型,那么剩余三个字节使用`0`进行填充.
 - 立即数寻址     movl $12, %eax                 非内存寻址：指令中有一个操作数是立即数 `$12`由CPU产生，不需要访问内存
 - 寄存器寻址     movl $12, %eax                 非内存寻址: 指令中有一个操作数是寄存器,`%eax`.在汇编程序中寄存器用助记符来表示，在机器指令中则要用几个Bit表示寄存器的编号，这几个Bit也可以看作寄存器的地址，但是和内存地址不在一个地址空间.                 
                         
备注：

 - 变址寻址  常用在数组中元素寻址场景中
 - 基址寻址  常用在结构体成员寻址场景中 (一般涉及到对齐问题,对齐的地址访问起来效率高)
 
关于基址寻址对齐，这里标注一下,我们写一个结构体，然后反汇编观察一下

    #include <stdio.h>
    
    int main(int argc, char** argv)
    {
        typedef struct {
            char a;
            int b;
            short c;
            char d;
        }st;
    
        st s;
        s.a = 1;
        s.b = 2;
        s.c = 3;
        s.d = 4;
    
        printf("%u \n ",sizeof(st));
        printf("%u %u  %u  %u \n ",s.a,s.b,s.c,s.d);
    
    }
    
    
    gcc -g test.c  
    objdump -dS a.out > 1.txt
    cat 1.txt

在反汇编结果中找到对应指令,

    printf("%u %u  %u  %u \n ",s.a,s.b,s.c,s.d);
    400565:	0f b6 45 fa          	movzbl -0x6(%rbp),%eax
    ...
    40056c:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
    ...
    400573:	8b 55 f4             	mov    -0xc(%rbp),%edx
    400576:	0f b6 45 f0          	movzbl -0x10(%rbp),%eax

地址都是`4`的倍数