## I/O缓冲区

#### 什么是缓冲区

我们经常用如下代码

    char buf[10];
    strncpy(buf, "hello world", sizeof(buf));
    // man 3 strncpy 

**像`buf`这种由调用者分配并传给函数读或写的一段内存通常称为缓冲区`Buffer`**，缓冲区写越界的错误称为缓冲区溢出`Buffer Overflow`
如果只是出现段错误那还不算严重，更严重的是缓冲区溢出`Bug`经常被恶意用户利用，使函数返回时跳转到一个事先设好的地址，执行事先设好的指令，
如果设计得巧妙甚至可以启动一个`Shell`，然后随心所欲执行任何命令，可想而知，如果一个用`root`权限执行的程序存在这样的`Bug`，被攻陷了，后果将很严重。

#### 为什么需要缓冲区

例如,在web应用环境中，通过socket一个字节一个字节的传输消息的方式对性能并不好。
更好的方式是把所有内容一次性传输给服务器，或者至少是一块一块地传输。层与层之间的数据交换的次数越少，性能越好。
(这是为了防止出现过大量的细小的写入操作，从而造成访问`SAPI`层过于频繁，这样网络消耗会很大，不利于性能)
你应该总是保持输出缓冲区处于可用状态.

#### 超重要 - C标准库的`I/O`缓冲区 

用户程序调用C标准`I/O库函数`读写文件或设备，而这些库函数要通过系统调用把读写请求传给内核（以后我们会看到与I/O相关的系统调用），
最终由内核驱动磁盘或设备完成`I/O操作`。C标准库为每个打开的文件分配一个`I/O缓冲区`以加速读写操作，通过文件的`FILE结构体`可以找到这个缓冲区，
用户调用读写函数大多数时候都在`I/O缓冲区`中读写，只有少数时候需要把读写请求传给内核。
以`fgetc/fputc`为例，当用户程序第一次调用`fgetc`读一个字节时，`fgetc`函数可能通过系统调用进入内核读`1K字节`到`I/O缓冲区`中，
然后返回`I/O缓冲区`中的`第一个字节`给用户，把读写位置指向`I/O缓冲区`中的第二个字符，以后用户再调`fgetc`，就直接从`I/O缓冲区`中读取，
而不需要进内核了，当用户把这`1K`字节都读完之后，再次调用`fgetc`时，`fgetc`函数会再次进入内核读`1K`字节到`I/O`缓冲区中。

在这个场景中用户程序、C标准库和内核之间的关系就像在第 5 节 “Memory Hierarchy”中CPU、Cache和内存之间的关系一样，
C标准库之所以会从内核预读一些数据放在`I/O缓冲区`中，是希望用户程序随后要用到这些数据，
**C标准库的I/O缓冲区也在用户空间，直接从用户空间读取数据比进内核读数据要快得多。**

同样写数据时，用户程序调用`fputc`通常只是写到`I/O缓冲区`中，这样`fputc`函数可以很快地返回，如果`I/O缓冲区`写满了，
`fputc`就通过系统调用把`I/O`缓冲区中的数据传给内核(写满后才传递到内核)，内核最终把数据写回磁盘。

某些特殊场景中(比如打游戏),用户程序希望把`I/O`缓冲区中的数据立刻传给内核，让内核写回设备，这称为`Flush`操作，对应的库函数是`fflush`，
`fclose`函数在关闭文件之前也会自动执行`Flush`操作。
`fflush`函数用于确保数据写回了内核，以免进程异常终止时丢失数据。作为一个特例，调用`fflush(NULL)`可以对所有打开文件的`I/O缓冲区`做`Flush`操作。

**内核中也有自己的缓冲区**

##### `C标准I/O库函数`是如何用`系统调用`实现的. 

‵fopen(3)`

调用open(2)打开指定的文件，返回一个文件描述符（就是一个int类型的编号），分配一个FILE结构体，其中包含该文件的描述符、I/O缓冲区和当前读写位置等信息，返回这个FILE结构体的地址。

`fgetc(3)`

通过传入的FILE *参数找到该文件的描述符、I/O缓冲区和当前读写位置，判断能否从I/O缓冲区中读到下一个字符，如果能读到就直接返回该字符，否则调用read(2)，把文件描述符传进去，让内核读取该文件的数据到I/O缓冲区，然后返回下一个字符。注意，对于C标准I/O库来说，打开的文件由FILE *指针标识，而对于内核来说，打开的文件由文件描述符标识，文件描述符从open系统调用获得，在使用read、write、close系统调用时都需要传文件描述符。

`fputc(3)`

判断该文件的I/O缓冲区是否有空间再存放一个字符，如果有空间则直接保存在I/O缓冲区中并返回，如果I/O缓冲区已满就调用write(2)，让内核把I/O缓冲区的内容写回文件。

`fclose(3)`

如果I/O缓冲区中还有数据没写回文件，就调用write(2)写回文件，然后调用close(2)关闭文件，释放FILE结构体和I/O缓冲区。


C标准库的I/O缓冲区有三种类型：全缓冲、行缓冲和无缓冲。当用户程序调用库函数做写操作时，不同类型的缓冲区具有不同的特性。

 - 全缓冲 如果缓冲区写满了就写回内核。常规文件通常是全缓冲的。
 - 行缓冲 如果用户程序写的数据中有`换行符`就把这一行写回内核，或者如果缓冲区写满了就写回内核。**标准输入和标准输出对应终端设备时通常是行缓冲的**。
 - 无缓冲 用户程序每次调库函数做写操作都要通过系统调用写回内核。**标准错误输出通常是无缓冲的**，这样用户程序产生的错误信息可以尽快输出到设备。
 
**注意**：用C标准I/O库函数要时刻注意I/O缓冲区和实际文件有可能不一致，在必要时需调用`fflush(3)`. 
      
### 参考资料地址

http://akaedu.github.io/book/ch25s02.html