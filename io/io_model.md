## 三种IO复用模型实现方式比较

#### IO复用之select、poll、epoll简介

　　`epoll`是`linux`所特有，而`select`是POSIX所规定，一般操作系统均有实现。

#### select

　　select本质是通过设置或检查存放fd标志位的数据结构来进行下一步处理。缺点是：

 1. 单个进程可监视的fd数量被限制，即能监听端口的数量有限。一般来说和系统内存有关，具体数目可以`cat /proc/sys/fs/file-max`查看。
    32位默认是`1024`个，64位默认为`2048`个.**对socket进行扫描时是线性扫描，即采用轮询方法，效率低**。
    当套接字比较多的时候，每次`select()`都要遍历`FD_SETSIZE`个socket来完成调度，不管`socket`是否活跃都遍历一遍。
    会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，就避免了轮询，这正是`epoll`与`kqueue`做的.
 1. 需要维护一个用来存放大量`fd`的数据结构，会使得用户空间和内核空间在传递该结构时复制开销大
 
使用方式
 
先accept再select的吧，这样丧失了select的优势，应该先select再accept，这样accept的时候可以立即返回，
调用select的时候本身就限制了最大连接数，`select(FD_SETSIZE, &testfds, (fd_set *)0,(fd_set *)0, (struct timeval *) 0);` FD_SETSIZE 预定义的就是1024。

#### poll

　　poll本质和select相同，将用户传入的数据拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，
如果遍历所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或主动超时，被唤醒后又要再次遍历fd。
**它没有最大连接数的限制，原因是它是基于链表来存储的**，但缺点是：

 1. 仍然存在大量的fd的数组被整体复制到用户态和内核空间之间，不管有无意义。
 1. poll还有一个特点“水平触发”，如果报告了fd后，没有被处理，那么下次poll时再次报告该ffd。

#### epoll

　　`epoll`支持水平触发和边缘触发，最大特点在于边缘触发，只告诉哪些fd刚刚变为就绪态，并且只通知一次。(难道是分了两个队列？)
还有一特点是，epoll使用“事件”的就绪通知方式，通过`epoll_ctl`注册fd，一量该fd就绪，内核就会采用类似`callback`的回调机制来激活该fd，
`epoll_wait`便可以收到通知。epoll的优点：

 1. 没有最大并发连接的限制。
 1. 效率提升，只有活跃可用的FD才会调用`callback`函数。
 1. 内存拷贝，利用`mmap()`文件映射内存加速与内核空间的消息传递。
 

注意,`epoll`算是异步IO吗 
 
#### 总结

虽然`epoll`在某些场景下表现优于`poll`,但是并不能完全取代`poll`.