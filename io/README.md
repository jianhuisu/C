## IO 知识简介 

FILE是C标准库中定义的结构体类型，其中包含该文件在内核中标识（在第 2 节 “C标准I/O库函数与Unbuffered I/O函数”将会讲到这个标识叫做文件描述符）、
I/O缓冲区和当前读写位置等信息，但调用者不必知道FILE结构体都有哪些成员，我们很快就会看到，
调用者只是把文件指针在库函数接口之间传来传去，而文件指针所指的FILE结构体的成员在库函数内部维护，
调用者不应该直接访问这些成员，这种编程思想在面向对象方法论中称为封装（Encapsulation）。
**像FILE *这样的指针称为不透明指针（Opaque Pointer）或者叫句柄（Handle）**，(这个概念实在太常用了,一定要理解)
FILE *指针就像一个把手（Handle），抓住这个把手就可以打开门或抽屉，但用户只能抓这个把手，而不能直接抓门或抽屉。


 - 以字节为单位的I/O函数(疑问:这个是不是应该称为以字符为单位? 使用本系列的IO函数获取中文会出现乱码问题)
 - 以字符串为单位的I/O函数

#### fopen 与 fclose

fopen调用应该和fclose调用配对，打开文件操作完之后一定要记得关闭。如果不调用fclose，在进程退出时系统会自动关闭文件，
但是不能因此就忽略fclose调用，如果写一个长年累月运行的程序（比如网络服务器程序），打开的文件都不关闭，堆积得越来越多，就会占用越来越多的系统资源。
换句话说 可能某天你封装的函数就会在常驻内存程序中引用,显然,如果你成对使用fopen/fclose，你就可以放心的引用了.

#### perror() 与 errno

所以一个系统函数错误返回后应该马上检查errno，在检查errno之前不能再调用其它系统函数。
    
    #include <stdio.h>
    #include <errno.h>
    #include <stdlib.h>
     
    if (fp == NULL) {
            perror("Open file abcde");
            printf("errno: %d\n", errno);
            exit(1);
    }
    
`printf`打印的错误号可能并不是`fopen`产生的错误号，也有可能是`perror`产生的错误号.
`errno`是一个全局变量，很多系统函数都会改变它.
大多数系统函数都有一个`Side Effect`，就是有可能改变`errno`变量.
虽然`perror`可以打印出错误原因，传给`perror`的字符串参数仍然应该提供一些额外的信息，以便在看到错误信息时能够很快定位.

`strerror`函数可以根据错误号返回错误原因字符串.

    #include <string.h>
    char *strerror(int errnum);
    
这个函数返回指向静态内存的指针(返回值：错误码`errnum`所对应的字符串).有些函数的错误码并不保存在`errno`中，而是通过返回值返回，
就不能调用`perror`打印错误原因了，这时`strerror`就派上了用场.

    int n = func_call(...);
    fputs(strerror(n), stderr);
    
### fgetc / getchar() / getc()

系统对于每个打开的文件都记录着当前读写位置在文件中的地址（或者说距离文件开头的字节数），也叫偏移量`Offset`。
当文件打开时，读写位置是`0`，每调用一次`fgetc`，读写位置向后移动一个字节，因此可以连续多次调用`fgetc`函数依次读取多个字节。

从终端设备读有点特殊。当调用`getchar()`或`fgetc(stdin)`时，如果用户没有输入字符，`getchar`函数就阻塞等待，
所谓阻塞是指这个函数调用不返回，也就不能执行后面的代码，这个进程阻塞了，操作系统可以调度别的进程执行。
**从终端设备读还有一个特点，用户输入一般字符并不会使`getchar`函数返回，仍然阻塞着，
只有当用户输入回车或者到达文件末尾时`getchar`才返回**。这个程序的执行过程分析如下：

    $ ./a.out
    hello（输入hello并回车，这时第一次调用getchar返回，读取字符h存到文件中，然后连续调用getchar五次，读取ello和换行符存到文件中，第七次调用getchar又阻塞了）
    hey（输入hey并回车，第七次调用getchar返回，读取字符h存到文件中，然后连续调用getchar三次，读取ey和换行符存到文件中，第11次调用getchar又阻塞了）
    （这时输入Ctrl-D，第11次调用getchar返回EOF，跳出循环，进入下一个循环，回到文件开头，把文件内容一个字节一个字节读出来打印，直到文件结束）
    hello
    hey

操作打开文件的`offset`的函数

操作读写位置的函数

 - `rewind`函数把读写位置移到文件开头. `void rewind(FILE *stream);`
 - `ftell`可以返回当前的读写位置. `long ftell(FILE *stream);`
 - `fseek`可以任意移动读写位置. `int fseek(FILE *stream, long offset, int whence);`

fseek的whence和offset参数共同决定了读写位置移动到何处，whence参数的含义如下：

 - SEEK_SET  从文件开头移动offset个字节
 - SEEK_CUR  从当前位置移动offset个字节
 - SEEK_END  从文件末尾移动offset个字节

`offset`可正可负，负值表示向前（向文件开头的方向）移动，
正值表示向后（向文件末尾的方向）移动，如果向前移动的字节数超过了文件开头则出错返回，
如果向后移动的字节数超过了文件末尾，再次写入时将增大文件尺寸，从原来的文件末尾到fseek移动之后的读写位置之间的字节都是0。        

### fgets() / puts()
        
 - gets函数的存在只是为了兼容以前的程序，我们写的代码都不应该调用这个函数. 
 - 输入输出函数应该配套使用，`fgets() + fputs()` 而不是`fgets() + puts()`,否则会因为对结束特殊处理方式不同,而出现一些意外问题.
 
现在解释一下`fgets()`函数的工作流程:

    char buf[5];
    while( fgets(buf,5,fp) !=  NULL ){
        fputs(buf,stdout);
    }

 1. 假设输入字符串为""mynameissujianhui",**读取以`'\n'`结尾的一行（包括`'\n'`在内）**存到`缓冲区buf`中因为一行内容超过缓冲区容量,
    所以需要多次读取,才能完整的读取完成输入字符串.
 1. 当`fgets()`每次从`句柄 fp`读取`5-1`(缓冲区长度size-1)个字符时,还没有读取到`'\n'`字符,
    已经读到的`size-1`个字符 + `一个'\0'字符`存入缓冲区(正好填满缓冲区)，剩下的部分可以在下次调用`fgets`时继续读.
 1. 如果一次`fgets`调用在读入若干个字符后到达文件末尾，则将已读到的字符串加上'\0'存入缓冲区并返回.
 1. 再次调用`fgets`则返回`NULL`，可以据此判断是否读到文件末尾.(使用gdb调试观察)
 
 
意：`fgets`只适合读文本文件而不适合读二进制文件，并且文本文件中的所有字符都应该是可见字符，不能有`'\0'`.(想一想为什么 跟`'/0'`有关)

### C标准库的I/O缓冲区 (超重要!!!)

用户程序调用C标准`I/O库函数`读写文件或设备，而这些库函数要通过系统调用把读写请求传给内核（以后我们会看到与I/O相关的系统调用），
最终由内核驱动磁盘或设备完成`I/O操作`。C标准库为每个打开的文件分配一个`I/O缓冲区`以加速读写操作，通过文件的`FILE结构体`可以找到这个缓冲区，
用户调用读写函数大多数时候都在`I/O缓冲区`中读写，只有少数时候需要把读写请求传给内核。(注释：局部性预读原理,系统调用需要排队,开销大)
以`fgetc/fputc`为例，当用户程序第一次调用`fgetc`读一个字节时，`fgetc`函数可能通过系统调用进入内核读`1K字节`到`I/O缓冲区`中，
然后返回`I/O缓冲区`中的`第一个字节`给用户，把读写位置指向`I/O缓冲区`中的第二个字符，以后用户再调`fgetc`，就直接从`I/O缓冲区`中读取，
而不需要进内核了，当用户把这`1K`字节都读完之后，再次调用`fgetc`时，`fgetc`函数会再次进入内核读`1K`字节到`I/O`缓冲区中。
在这个场景中用户程序、C标准库和内核之间的关系就像在第 5 节 “Memory Hierarchy”中CPU、Cache和内存之间的关系一样，
C标准库之所以会从内核预读一些数据放在`I/O缓冲区`中，是希望用户程序随后要用到这些数据，
**C标准库的I/O缓冲区也在用户空间，直接从用户空间读取数据比进内核读数据要快得多。**
另一方面，用户程序调用`fputc`通常只是写到`I/O缓冲区`中，这样`fputc`函数可以很快地返回，如果`I/O缓冲区`写满了，
`fputc`就通过系统调用把`I/O`缓冲区中的数据传给内核，内核最终把数据写回磁盘。(写满后才传递到内核)
有时候用户程序希望把`I/O`缓冲区中的数据立刻传给内核，让内核写回设备，这称为`Flush`操作，对应的库函数是`fflush`，`fclose`函数在关闭文件之前也会做`Flush`操作。
`fflush`函数用于确保数据写回了内核，以免进程异常终止时丢失数据。作为一个特例，调用`fflush(NULL)`可以对所有打开文件的`I/O缓冲区`做`Flush`操作。


现在看看`C标准I/O库函数`是如何用`系统调用`实现的.

fopen(3)

调用open(2)打开指定的文件，返回一个文件描述符（就是一个int类型的编号），分配一个FILE结构体，其中包含该文件的描述符、I/O缓冲区和当前读写位置等信息，返回这个FILE结构体的地址。

fgetc(3)

通过传入的FILE *参数找到该文件的描述符、I/O缓冲区和当前读写位置，判断能否从I/O缓冲区中读到下一个字符，如果能读到就直接返回该字符，否则调用read(2)，把文件描述符传进去，让内核读取该文件的数据到I/O缓冲区，然后返回下一个字符。注意，对于C标准I/O库来说，打开的文件由FILE *指针标识，而对于内核来说，打开的文件由文件描述符标识，文件描述符从open系统调用获得，在使用read、write、close系统调用时都需要传文件描述符。

fputc(3)

判断该文件的I/O缓冲区是否有空间再存放一个字符，如果有空间则直接保存在I/O缓冲区中并返回，如果I/O缓冲区已满就调用write(2)，让内核把I/O缓冲区的内容写回文件。

fclose(3)

如果I/O缓冲区中还有数据没写回文件，就调用write(2)写回文件，然后调用close(2)关闭文件，释放FILE结构体和I/O缓冲区。


C标准库的I/O缓冲区有三种类型：全缓冲、行缓冲和无缓冲。当用户程序调用库函数做写操作时，不同类型的缓冲区具有不同的特性。

 - 全缓冲 如果缓冲区写满了就写回内核。常规文件通常是全缓冲的。
 - 行缓冲 如果用户程序写的数据中有`换行符`就把这一行写回内核，或者如果缓冲区写满了就写回内核。**标准输入和标准输出对应终端设备时通常是行缓冲的**。
 - 无缓冲 用户程序每次调库函数做写操作都要通过系统调用写回内核。**标准错误输出通常是无缓冲的**，这样用户程序产生的错误信息可以尽快输出到设备。
 
**注意**：用C标准I/O库函数要时刻注意I/O缓冲区和实际文件有可能不一致，在必要时需调用`fflush(3)`. 
      
### 参考资料地址

http://akaedu.github.io/book/ch25s02.html