
对于(A3A2A1A0)2这样一个二进制数，
最左边的A3位称为最高位（MSB，Most Significant Bit），
最右边的A0位称为最低位（LSB，Least Significant Bit）。
我们遵循这样的惯例：LSB称为第0位而不是第1位，所以如果一个数是32位的，则MSB是第31位

左高右低

13=1×23+1×22+0×21+1×20

所以13换算成二进制应该是(1101)2。

问题是怎么把13分解成等号右边的形式呢？注意到等号右边可以写成
13=((((0×2+13)×2+12)×2+01)×2+10   进而可以推导出 除2取余法(除二反序取余法)

计算机用二进制表示数，程序员也必须习惯使用二进制，但二进制写起来太啰嗦，
所以[通常将二进制数分成每三位一组或者每四位一组，每组用一个数字表示]。
比如把(10110010)2从最低位开始每三位分成一组，10、110、010，然后把每组写成一个十进制数字，就是(262)8，这样每一位数字的取值范围是0~7，逢八进一，称为八进制（Octal）。
类似地，把(10110010)2分成每四位一组，1011、0010，然后把每组写成一个数字，这个数的低位是2，高位已经大于9了，我们规定用字母A~F表示10~15，这个数可以写成(B2)16，
每一位数字的取值范围是0~F，逢十六进一，称为十六进制（Hexadecimal）。所以，八进制和十六进制是程序员为了书写二进制方便而发明的简便写法，好比草书和正楷的关系一样。

1、二进制小数可以这样定义：

(0.A1A2A3...)2=A1×2-1+A2×2-2+A3×2-3+...
(0.101)_2 => 0.(1 * 2^-1 + 0 * 2^-2 + 1 *2^-3)_10 = 0.75



模的概念：任何有模的计量器，均可化减法为加法运算。在12为模的系统里(时钟)，加10和减2效果是一样的，因此凡是减2运算，都可以用加10来代替。

对“模”而言，2和10互为补数。实际上，以12为模的系统中，11和1，8和4，9和3，7和5，6和6都有这个特性
共同的特点是两者相加等于模。对于计算机，其概念和方法完全一样。n位计算机，设n=8，所能表示的最大数是11111111，若再加1成100000000(9位)，但因只有8位，最高位1自然丢失。
又回到了 00000000，所以8位二进制系统的模为 。在这样的系统中减法问题也可以化成加法问题，只需把减数用相应的补数表示就可以了。把补数用到计算机对数的处理上，就是补码

如果两数符号位相同，就把它们的低7位相加，符号位不变。如果低7位相加时在最高位产生进位，说明结果的绝对值大于127，超出7位所能表示的数值范围，这称为溢出（Overflow）
把正整数溢出称为上溢（Overflow），负整数溢出称为下溢（Underflow）
取1的补码更简单，连减法都不用做，因为1-1=0，1-0=1，取1的补码就是把每个bit取反，所以1的补码也称为反码

负数的取值范围是从10000000到11111111（-127~0），正数是从00000000到01111111（0~127），仍然可以根据最高位判断一个数是正是负。
美中不足的是0的表示仍然不唯一，既可以表示成11111111也可以表示成00000000

参考资料：

    LinuxC编程一站式学习  宋劲杉
