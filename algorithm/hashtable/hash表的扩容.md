## hash表的扩容

#### Hash表（Hash Table）
 
`hash表`实际上由`size`个的`桶`组成一个`桶数组``table[0...size-1] `.
当一个对象经过哈希之后。得到一个对应的`hash value`,于是我们把这个对象放到`桶 table[value]`中。
当一个桶中有多个对象时,我们把桶中的对象组织成为一个链表。这在冲突处理上称之为拉链法。

#### 负载因子（load factor）

如果一个`hash表`中桶的个数为`size`, 存储的元素个数为`used`.则我们称 `used / size` 为负载因子`loadFactor` .
一般的情况下，当`loadFactor<=1`时，hash表查找的期望复杂度为`O(1)`. 因此，每次往hash表中加入元素时我们必须保证是在`loadFactor <1`的情况下才可以加入.

#### 容量扩张（Expand）& 分摊转移

当我们加入一个新元素时。一旦`loadFactor`大于等于1了，我们不能单纯的往hash表里边加入元素。
因为继续添加元素,`loadFactor`必定大于1，这样就无法保证查找的期望时间复杂度为常数级.
此时我们需要对桶数组进行容量扩张,让`size`增大以保证加入元素后`loadFactor`仍然小于等于1,从而保证查找的期望时间复杂度为O(1).

如何进行扩容呢？ 

#####  C++中的`STL vector`扩容思路

Hash表中每次发现`loadFactor==1`时，就开辟一个原来桶数组的两倍空间（称为新桶数组），
然后把原来的桶数组中元素所有转移过来到新的桶数组中。这里转移指元素需要重新经过哈希计算插入到新桶中的.

这样的方法的缺点是，容量扩张是一次完毕的，当hash表中`loadFactor==1`时,往里边插入一个元素将会等候非常长的时间.

##### `redis`中的`dict.c`中的扩容思路

用两个hash表来进行进行扩容和转移的工作:

 1. 假设要往字典里插入一个元素,发现`hashtable_0`的`loadFactor>=1`,需要扩容.
 1. 新建一个hash表`hashtable_1`,其容量等于第一个hash表`hashtable_0`容量的`2倍`.
 1. 将`hashtable_0`中一个非空桶中所有元素转移到`hashtable_1`中,然后把待插入元素存储到`hashtable_1`中.
 1. 插入第二个元素时,重复上述三个步骤.直到`hashtable_0`中桶全部完成转移.
 1. 释放`hashtable_0`,将指向`hashtable_0`的指针指向`hashtable_1`. 

`redis`的策略就是把一次转移分摊为多次转移，并且每次转移的期望时间复杂度为`O(1)`.

##### 为什么拉链时采用头插法

保证插入时的操作复杂度为O(1).