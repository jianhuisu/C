## 排序

已知待排序的数据记录

 - 数据记录          `R1 R2 R3 R4 R5 R6 ...`
 - 数据纪录对应关键字  `K1 K2 K3 K4 K5 K6 ...`

如果关键字是`主关键字`,那么排序结果是唯一的.
如果关键字是`次关键字`,那么排序结果可能不唯一.此时排序方法会有`稳定排序方法`,`不稳定排序方法`之分.

根据待排序的数据存储位置不同(少量数据可以存储在主存中,海量数据存储在外存),排序算法可分为两大类:

 - 内部排序  待排序数据全部存储在主存中,
 - 外部排序  待排序的数据记录无法一次性全部装入主存,部分乃至全部存储在外存中.排序过程中涉及到对外存的访问(例如mysql的索引,数据).
 
**内部排序的算法有很多,但是很难提出一种就全面性而言最好的算法.每一种算法都有自己的优缺点,适合不同的环境.**

如果按照内部排序的时间复杂度来分类,可以主要分为以下三个等级

 - 简单排序  时间复杂度 `O(n^2)` 
 - 先进排序  时间复杂度 `O(n*logn)`
 - 基数排序  时间复杂度 `O(d*n)`
 
注意:并不能单纯的依靠时间复杂度来评价一个算法的好坏,空间复杂度以及其一些特定场景都影响我们对算法的选择.
 
`原地排序`指在排序过程中不申请多余的存储空间，只利用已有的存储待排数据的存储空间进行比较和交换的 排序算法.
属于原地排序的算法有：

 - 希尔排序
 - 冒泡排序
 - 插入排序
 - 选择排序
 - 堆排序
 - 快速排序
 
#### 排序 操作步骤拆解

通常分为两步

 1. 比较两个关键字的大小.
 2. 按比较结果,移动两个关键字的位置.

其中`step.1`是必须的,而在`step.2`上,我们可以做点文章.对于`step.2`,可以细分为以下三种场景.

 1. 数组排序: 待排序的一组数据记录存储在`一组地址连续的`内存单元上(可以理解为存储在`顺序表/数组`中),`step.2`无法优化.
 1. 链表排序: 待排序的一组数据记录存储在链表中,此时`step.2`可以替换为更换两条数据记录的指针.数据记录本身不需要移动.
 1. 地址排序: 待排序的一组数据记录存储在`一组地址连续的`内存单元上,但是我们另外设置了一组指示各条记录存储位置的`地址向量`(也就是指针数组).此时`step.2`可以替换为移动地址而不是数据记录本身.
 
 
 


 

 