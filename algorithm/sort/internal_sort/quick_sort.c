#include <stdio.h>
#define MAX_SIZE 10
int wait_sort[MAX_SIZE] = {11,15,20,13,17,65,27,49,99,18};

void show(int * s,int length)
{
    int i ;
    for(i=0;i<length;i++){
        printf(" %d ",s[i]);
    }

    printf("\n");
}

void swap(int * i,int * j)
{
    int temp;
    temp = *i;
    *i = *j;
    *j = temp;
}

void sort(int *a, int left, int right)
{
    // 快速错误
    if(left >= right){
        return ;
    }
    show(a,6);
    int i = left;
    int j = right;
    int key = a[left];  // 选取第一个元素为枢纽点

    // 快速排序的一次划分算法从两头交替搜索，直到low和high重合，因此其时间复杂度是O(n)；
    while(i < j)
    {
        // 从右向左寻找第一个小于枢纽点的元素 ， 与最低位元素进行 位置互换
        while(i < j && key <= a[j])
        {
            j--;/*向前寻找*/
        }
        swap(&a[i],&a[j]);

        // 从左向右寻找第一个大于枢纽点的元素 ，从左边序列剔除,插入右边序列(即与枢纽点互换，保证元素在枢纽点的右侧序列)
        while(i < j && key >= a[i])
        {
            i++;
        }

        swap(&a[i],&a[j]);
        //a[j] = a[i];
    }

    //a[i] = key;/*当在当组内找完一遍以后就把中间数key回归*/
    sort(a, left, i - 1);/*最后用同样的方式对分出来的左边的小组进行同上的做法*/
    sort(a, i + 1, right);/*用同样的方式对分出来的右边的小组进行同上的做法*/
}


int main(void)
{
    int arr[6] = {3 ,9 ,4 ,2 ,7 ,1};
    sort(arr,0,5);
    show(arr,6);
    return 0;
}

// 疑问： 快速排序是如何保证 左边的任意一个数 小于 右边序列中的任意一个数 : 数往两边扔 ，多挑几次，多扔几次 ，就可以保证左边小于右边

/*

快速排序的一次划分算法从两头交替搜索，直到low和high重合，因此其时间复杂度是O(n)；而整个快速排序算法的时间复杂度与划分的趟数有关。
理想的情况是，每次划分所选择的中间数恰好将当前序列几乎等分，经过log2n趟划分，便可得到长度为1的子表。这样，整个算法的时间复杂度为O(nlog2n)
最坏的情况是，每次所选的中间数是当前序列中的最大或最小元素，----!!!->这使得每次划分所得的子表中有一个为空表<----!!!!--，另一子表的长度为原表的长度-1。这样，长度为n的数据表的快速排序需要经过n趟划分，使得整个排序算法的时间复杂度为O(n^2)。

为改善最坏情况下的时间性能，可采用其他方法选取中间数。通常采用“三者值取中”方法，即比较H->r[low].key、H->r[high].key与H->r[(10w+high)/2].key，取三者中关键字为中值的元素为中间数。

可以证明，快速排序的平均时间复杂度也是O(nlog2n)。因此，该排序方法被认为是目前最好的一种内部排序方法。

从空间性能上看，尽管快速排序只需要一个元素的辅助空间，但快速排序需要一个栈空间来实现递归。最好的情况下，即快速排序的每一趟排序都将元素序列均匀地分割成长度相近的两个子表，所需栈的最大深度为log2(n+1)；
但最坏的情况下，栈的最大深度为n。这样，快速排序的空间复杂度为O(log2n))。

 */

// 第一次序列划分完成后 ，如果左边序列中的最大值 大于右边序列的最小值,而快速排序不像 归并排序 ，中间有一个merge的过程。那么上面的情况是如何解决的呢?
// 原始序列 { 3 9 4 2 7 1} . left { 3 1 4 } right { 2 7 9 }
