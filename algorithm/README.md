todo 为什么会有多种排序算法？
todo 但是不是任何情况下归并排序都优于插入排序呢？
todo 哪些情况适用插入排序而不适用归并排序？

时间复杂度分为

    最优时间复杂度
    平均时间复杂度
    最坏时间复杂度

在分析算法的时间复杂度时，我们更关心最坏情况而不是最好情况，理由如下：

    1 最坏情况给出了算法执行时间的上界，我们可以确信，无论给什么输入，算法的执行时间都不会超过这个上界，这样为比较和分析提供了便利。
    2 对于某些算法，最坏情况是最常发生的情况，例如在数据库中查找某个信息的算法，最坏情况就是数据库中根本不存在该信息，
        都找遍了也没有，而某些应用场合经常要查找一个信息在数据库中存在不存在。
    3 虽然最坏情况是一种悲观估计，但是对于很多问题，平均情况和最坏情况的时间复杂度差不多，比如插入排序这个例子，平均情况和最坏情况的时间复杂度都是输入长度n的二次函数。

比较两个多项式

    a1n+b1 和 a2n2+b2n+c2 的值（n取正整数）

可以得出结论：
    n的最高次指数是最主要的决定因素，常数项、低次幂项和系数都是次要的。
    比如100n+1和n2+1，虽然后者的系数小，当n较小时前者的值较大，但是当n>100时，后者的值就远远大于前者了。
    如果同一个问题可以用两种算法解决，其中一种算法的时间复杂度为线性函数，
    另一种算法的时间复杂度为二次函数，当问题的输入长度n足够大时，
    前者明显优于后者。因此我们可以用一种更粗略的方式表示算法的时间复杂度，
    把系数和低次幂项都省去：
    
        线性函数记作Θ(n)
        二次函数记作Θ(n2)

Θ(g(n))表示和g(n)同一量级的一类函数，例如所有的二次函数f(n)都和g(n)=n^2属于同一量级，
都可以用Θ(n^2)来表示，甚至有些不是二次函数的也和n^2属于同一量级，例如2n^2+3lgn。

同一量级的概念：
    如果可以找到两个正的常数c1和c2，使得n足够大的时候（也就是n≥n0的时候）
    f(n)总是夹在c1g(n)和c2g(n)之间，就说f(n)和g(n)是同一量级的，f(n)就可以用Θ(g(n))来表示。

几种常见的时间复杂度函数按数量级从小到大的顺序依次是：

   O(1)   Θ(lgn)   Θ(sqrt(n))  Θ(n)   Θ(nlgn)  Θ(n^2)  Θ(n^3)  Θ(2^n) Θ(n!)
   常数阶  对数阶   平方根阶    线性阶

其中，lgn通常表示以10为底n的对数，但是对于Θ-notation来说，Θ(lgn)和Θ(log2n)并无区别(想一想这是为什么),
在算法分析中lgn通常表示以2为底n的对数。

除了Θ-notation之外，表示算法的时间复杂度常用的还有一种 Big-O notation。(这就是我们常说的大O表示法 或者说最坏时间复杂度)
我们知道插入排序在最坏情况和平均情况下时间复杂度是Θ(n2)，
在最好情况下是Θ(n)，数量级比Θ(n2)要小，
那么总结起来在各种情况下插入排序的时间复杂度是O(n^2)。
最好情况 ：大Ω记号-->如果存在正的常数c和函数g(n)，对任意n>>2，有T(n) > c * g(n)，即认为：在n足够 大后，g(n)给出了T(n)的一个下界，记为：

    Θ的含义和"等于"类似          约等于   sei他
    大O的含义和"小于等于"类似    有上界    鸥
    大Ω含义和"大于等于" 类似     有下界    欧蜜歌

排序稳定性

    稳定性就是指对于两个关键字相等的记录，它们在序列中的相对位置，在排序之前和排序之后没有发生改变。
    通俗地讲就是有两个关键字相等的数据A、B，排序前，A的位置是 i ，B的位置是 j，此时 i < j，
    则如果在排序后A的位置还是在B之前，那么称它是稳定的。
    它的好处是，如果排序算法都是稳定的，那么第一个排序结果可以为另一个排序所用，
    也就是说稳定排序可以用于两个关键字的排序，比如，现在要根据英语成绩排一下大家的成绩，然后在根据数学成绩排一下大家的成绩，
    如果用的是稳定排序的话，就可以保证数学成绩相同的人里英语分高的人排在更前面。
    有点类似mysql的排序语句：select ... from ... order by math_score DESC,english_score DESC;

参考资料：
    LinuxC编程一站式学习  宋劲杉