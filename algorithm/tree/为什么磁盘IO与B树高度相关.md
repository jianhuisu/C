## 为什么磁盘IO次树与B树高度相关

链式存储结构中树的结点之间依靠结点中的指针域相连.相当于每一次根据父结点的指针寻找子结点时,
都有可能引发磁盘IO.在二叉树中从父结点寻找子结点实质就是从上层向下层遍历.所以树的高度决定磁盘IO的次数.

那`B-树`是如何降低树的高度呢？

首先假设关键字的个数为N.

 - 在AVL树中,一个结点存储一个关键字.则AVL树有N个结点.AVL树的深度为`ceil(logN) + 1`.最多可以引发`ceil(logN) + 1`次磁盘IO.
 - 在m阶的B-树中(m>2),一个结点存储1024个关键字.(2^10).则B-树中将会存在`N/2^10`个结点.`B-`树的深度为`ceil(以m为底N/2^10的对数)`.肯定是远小于AVL的深度.

再从操作系统方面来解释一下.

B_树的一个结点虽然可以容纳成百上千的关键字，指针等等域.但是一个结点绝对不会超过一个磁盘块大小(一般磁盘的section在1KB-4KB之间).
这确保了一个结点不会分两次IO.操作系统控制内存与磁盘之间一次数据交换是以页为单为的.
`1 page = 4K`.即使你要求访问的数据大小远远小于`4KB`,这涉及到磁盘的预读即数据的局部性原理.
每次IO时操作系统会载入`4K`的数据进入内存.(即从指定位置开始,读取4K长度的数据.)如果一个结点保存一个关键字.
这并不能填满4K.辛辛苦苦IO一次.却只load了一个关键字.树很高时,查一个关键字自然要经过很多次磁盘IO.
所以B-树一个结点存储大量关键字.**在B-树上进行查找过程是一个 顺指针查找结点,和在结点内部大量关键字中进行内部查找 交叉进行的过程**.正是基于这种结构.
B-树将高瘦树变为了矮胖树.极大的降低了磁盘IO次数.为大文件索引提速.

#### B- 树的升级版本

在关键字个数相同的条件下,B+树是比B-树更矮更胖的多路平衡查找树.

在涉及磁盘的外部查找场景中,B_树虽然比AVL优秀.但是B-树也存在一些缺点.

 - B-树的查询效率不够稳定.可能第一个结点内就查到了数据,也有可能在叶子结点上才查到数据.
 - N个关键字分布在整棵树上.每一个结点中都存有关键字.
 - B-树的结点内部不仅仅存储了关键字和指针,它还有数据域.数据域的存在挤压了关键字的空间.(例如,一个结点最大占用一个section,如果把data占用的空间分配给key,则结点中key的存储量又可以获得提升)

B+树针对于B-树的缺点,进行了一次进化.

##### Tips.1

`B+ Tree`有一个很大的改变就是分支结点的结点内部中没有`data`域，全部变成了key域.`data`域全部存放在叶子结点上.
有了更多的空间来存储更多的key.

这样的一个最大的好处就利用了局部性原理——磁盘预读的特性（磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存).
`B+ Tree`中结点的分支结点内部无`data`域,但是每次`IO`的页的大小是固定的，
那么每次IO就可以读取更多的key到主存.`B+树`单次磁盘IO的`key`数量大于B树,则key总数N一定时,`B+树`相对`B_树`磁盘IO次数更少.

数据库系统的设计者巧妙利用了磁盘预读原理，将一个结点的大小设为等于一个页，这样每个结点只需要一次`I/O`就可以完全载入。
为了达到这个目的在实际实现`B-Tree`还需要使用如下技巧：
每次新建结点时，直接申请一个页的空间，这样就保证一个结点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个`node`只需一次`I/O`.

###### Tips.2

`B+Tree`中因为数据都存储在叶子结点，所以每次查询的时间复杂度是固定的,每次查询的效率更加稳定.
叶子结点之间都是链表的结构，所以`B+ Tree`也是可以支持范围查询的，解决了B树遍历效率低下的问题.而B树每个结点`key`和`data`在一起，则无法区间查找。

综上所述：`B+`树比`B-`更适合应用在文件索引与数据库索引.

#### 参考资料

原文链接：https://blog.csdn.net/qq_36520235/article/details/94317993


