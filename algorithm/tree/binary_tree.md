## 二叉树

#### 树中常用术语

 - 结点
 - 根
 - 子结点
 - 兄弟结点
 - 终端结点/叶子结点
 - 分支结点 度不为0的结点称为非终端结点或分支结点 
 - 内部结点 (Branch/Internal node) 除根结点外,分支结点也称为内部结点.(维基百科称根结点结点也称为内部结点) 
 - 外部结点(External node) 也即叶子结点
 - 祖先
 - 子孙
 - 左子树
 - 右子树
 - 结点的度
 - 树的度
 - 树的深度
 - 结点的层数:规定根结点所在层数为第一层.
 
 
 结点拥有的子树个数称为结点的度(Degree),度为0的结点为叶结点(Leaf)或终端结点;度不为0的结点称为非终端结点或分支结点;除根结点外,分支结点也称为内部结点;树的度是树内各结点度的最大值;
 
#### 普通二叉树 ，满二叉树 与 完全二叉树 

**二叉树有5种基本形态**

 - 空二叉树 
 - 仅有根结点的二叉树
 - 右子树为空的二叉树
 - 左子树为空的二叉树
 - 左右子树不为空的二叉树

**满二叉树** 
 
 - 所有的分支结点都有左子树与右子树.
 - 并且所有的终端结点都在同一层
 - 每一层上的结点数都是最大结点数.

    满二叉树
             1 
        2         3
    4      5   6     7
  
    非满二叉树
    
    
             1 
        2         3
    4      5   6     
    （个别分支结点不具有右子树）
    
                 1 
            2         3
        4      5   6     7
      8    9
    （所有叶子结点不在同一层）
    
**完全二叉树**  

定义：结点编号与同深度的满二叉树中的结点编号相同的二叉树.

特性: 

 - 叶子结点只能出现在`最下层`或`次下层 `.
 - 最下层的叶子结点集中在树的左部.
 
满二叉树肯定是完全二叉树,但是完全二叉树不一定是满二叉树.

    完全二叉树
             1 
        2         3
    4      5   
  
             1 
        2         3
    4      5   6     
    
                 1 
            2         3
        4      5   6     7
      8    9
      
#### 二叉树的数学特性

 1. 一棵非空的二叉树的第`i`层上最多有`2^(i-1)`个结点.
 2. 一棵深度位`k`的二叉树.最多具有`2^k - 1`结点(满二叉树).最少有`k`个结点(单枝树).
 3. 对于一棵非空的二叉树,度为0的结点(终端结点)数`n0`总是比度为2的结点数`n2`多一个.`n0 = n2 + 1`.其结点总数为‵n = n0 + n1 + n2`.(因为二叉树中只存在这三种度的结点)
 4. 具有n个结点的完全二叉树的深度为`|_ logn _| + 1`,(不大于`logn`的最大整数`+1`.)
 5. 对具有n个结点的完全二叉树,结点的编号索引之间存储数学关系.如果根结点的编号为`0`(自上而下,自左而右),那么编号为`i`的父结点编号为`(i-1)/2`.
 左子结点编号为`2i+1`,右子结点编号为`2i+2`.(堆排序用到了这个关系).

**由于完全二叉树具有以上数学特性,在我们实现估算/查找/删除等操作时表现优良.所以我们经常把很多数据按照完全二叉树的模式存储.**
    
#### 二叉树的遍历

 - 先序遍历序列 + 中序遍历序列 => 后序遍历序列   可以.   即已知先序,中序序列可以构建二叉树. 
 - 后序遍历序列 + 中序遍历序列 => 先序遍历序列   可以.   即已知后序,中序序列可以构建二叉树.
 - 后序遍历序列 + 先序遍历序列 => 中序遍历序列   不可以.  即已知先序,后序序列只能确定根结点,无法确定左右子树,所以无法构建二叉树.

按遍历模型区分主要分为两大类

 - 递归遍历
 - 非递归遍历

#### 必须掌握知识点

递归遍历二叉树
满二叉树,完全二叉树的特点
已知先序，中序 ，推导后序序列
使用非递归算法求树的深度
如何判断一个二叉树是否为一个平衡二叉树
哈夫曼遍码














二叉树是一种非常重要的数据结构，很多其他数据结构都是基于二叉树的基础演变过来的。
(我们所说的数据结构默认都是指逻辑数据结构,而计算机在存储时受到物理条件的限制,只能执行一些一维固定的操作,(物理存储结构只有两种 顺序存储/链式存储) 计算机学科难就难在如何用非常简单的固定组合去表示复杂的逻辑数据结构)
比如我们可以固定二叉树的表示,然后归纳出二叉树可以与多叉树(森林)之间相互转换表示的规律.就可以在计算机中表示森林.一粒沙加上你的想象,这就是世界.

结构要先创建才能使用

    先有想法 逻辑结构
    设计结构  struct
    实现存储  赋值 初始化
    使用结构  遍历 输出 表示信息

二叉树是一种非线性结构,我们在存储二叉树时需要将二叉树转化为线性结构才能存储.如何将二叉树转化为线性结构呢,
就是通过遍历规则.也就是说：

 - 对二叉树遍历才能获得线性序列(得到有线性序列我们才能存储)
 - **不同的遍历规则所得的线性序列不同(波兰式/逆波兰式)**
  
二叉树有前、中、后三种遍历方式(不包括层序遍历)，因为树的本身就是用递归定义的，因此采用递归的方法实现三种遍历，不仅代码简洁且容易理解，但其开销也比较大，
而若采用`非递归`方法实现三种遍历，则要用栈来模拟实现（递归也是用栈实现的）。下面先简要介绍三种遍历方式的递归实现，再详细介绍三种遍历方式的非递归实现。

递归    ： 自己套自己   第归的层数是有限制的 ，否则会产生爆栈的问题
循环遍历 ： 借助外界游标,标注当前结点

### 递归遍历

    略
    
### 非递归遍历

               a
        b               c
    d      e        f


##### 先序遍历非递归实现 

根据先序遍历的顺序

 1. 先访问根节点，
 1. 再访问左子树，
 1. 后访问右子树，

 
而对于每个子树来说，又按照同样的访问顺序进行遍历，上图的先序遍历顺序为：`ABDECF`。非递归的实现思路如下：
对于任一节点P，

 1. 输出节点P，然后将其入栈，再看P的左孩子是否为空；
 2. 若P的左孩子不为空，则置P的左孩子为当前节点，重复1）的操作；
 3. 若P的左孩子为空，则将栈顶节点出栈，但不输出，并将出栈节点的右孩子置为当前节点，看其是否为空；
 4. 若不为空，则循环至1）操作；
 5. 如果为空，则继续出栈，但不输出，同时将出栈节点的右孩子置为当前节点，看其是否为空，重复4）和5）操作；
 6. 直到当前节点P为NULL并且栈空，遍历结束。

##### 中序遍历的非递归实现

根据中序遍历的顺序，先访问左子树，再访问根节点，后访问右子树，而对于每个子树来说，又按照同样的访问顺序进行遍历，上图的中序遍历顺序为：DBEAFC。非递归的实现思路如下：
对于任一节点P，

 1. 若P的左孩子不为空，则将P入栈并将P的左孩子置为当前节点，然后再对当前节点进行相同的处理；
 2. 若P的左孩子为空，则输出P节点，而后将P的右孩子置为当前节点，看其是否为空；
 3. 若不为空，则重复1）和2）的操作；
 4. 若为空，则执行出栈操作，输出栈顶节点，并将出栈的节点的右孩子置为当前节点，看起是否为空，重复3）和4）的操作；
 5. 直到当前节点P为NULL并且栈为空，则遍历结束。

##### 后序遍历的非递归实现

根据后序遍历的顺序，先访问左子树，再访问右子树，后访问根节点，而对于每个子树来说，又按照同样的访问顺序进行遍历，上图的后序遍历顺序为：DEBFCA。
后序遍历的非递归的实现相对来说要难一些，要保证根节点在左子树和右子树被访问后才能访问，思路如下：

对于任一节点P，

 1. 先将节点P入栈；
 2. 若P不存在左孩子和右孩子，或者P存在左孩子或右孩子，但左右孩子已经被输出，则可以直接输出节点P，并将其出栈，将出栈节点P标记为上一个输出的节点，再将此时的栈顶结点设为当前节点；
 3. 若不满足2）中的条件，则将P的右孩子和左孩子依次入栈，当前节点重新置为栈顶结点，之后重复操作2）；
 4. 直到栈空，遍历结束。

### 常见二叉树变种
 
满二叉树如果右结点存在 那么左结点肯定存在
二叉树是有序的(所以 先有左子树 后有右子树)
线索二叉树  在线索二叉树上遍历二叉树不需要设栈 如果某二叉树需要经常遍历，或者经常查找遍历所得线性序列中的前驱和后继，应该采用线索二叉树作为存储结构.

    {
        data;
        LTag;
        RTag;
        lchild;
        rchild;
    }
    
二叉树的线索化:线索化的过程就是在二叉树遍历时修正指针的过程.

最优二叉树/哈夫曼树 带权最小路径 哈夫曼编码

二叉搜索树/二叉排序树  因为存在退化为单枝树的情况
平衡二叉树 平衡因子 BF
B- 多路平衡查找树

判定树

        

### 

##### 空链域 

书上有句话说对一个二叉树来说，含有n个结点的二叉链表中有n+1个空链域到底指什么呢？？？？？

二叉树中：结点数`n=n1+n2+n0`,

 - n0是度数为0的结点，也称叶子结点
 - n1是度数为1的结点(只有左结点)
 - n2是度数为2的结点
 
设空链域个数为`N`,则`N=1*n1+2*n0`,（因为度为1的有一个空，度为0的有两个为空）
因为`n0=n2+1`,带入得`N=n1+n0+n2+1=n+1`

这里的空链应该指可以本来放置结点的位置，但实际上没有放置结点的位置.(也就是指针为NULL 的指针域)

    typedef struct elem{
        struct node_data d;
        struct * node left_child;
        struct * node right_child;
    }Node;

    {1,NULL,NULL}

##### 存储密度



### 参考资料

https://blog.csdn.net/a568478312/article/details/78980342
