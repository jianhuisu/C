该包代码来自于`C primer plus`,主要实现了二叉树的增删改查以及三种遍历.

代码包中的树的遍历是采用递归实现的.理论上讲,**可以用递归实现的功能都可以用栈来代替**.
只是递归更加符合人类的思维方式.代码看起来也比较简洁.
这并不能说明递归比栈的方式更快更节省时间.因为在递归的过程中,操作系统帮助我们使用栈来存储信息.
所以我们可以使用栈来实现二叉树的三种遍历.

二叉树有前、中、后三种遍历方式(不包括层序遍历)，因为树的本身就是用递归定义的，因此采用递归的方法实现三种遍历，不仅代码简洁且容易理解，但其开销也比较大，
而若采用`非递归`方法实现三种遍历，则要用栈来模拟实现（递归也是用栈实现的）。下面先简要介绍三种遍历方式的递归实现，再详细介绍三种遍历方式的非递归实现。

递归    ： 自己套自己   第归的层数是有限制的 ，否则会产生爆栈的问题
循环遍历 ： 借助`外界游标+栈`,标注当前结点

##### 先序遍历非递归实现 

根据先序遍历的顺序

 1. 先访问根节点，
 1. 再访问左子树，
 1. 后访问右子树，
 
而对于每个子树来说，又按照同样的访问顺序进行遍历，上图的先序遍历顺序为：`ABDECF`。非递归的实现思路如下：
对于任一节点P，

 1. 输出节点P，然后将其入栈，再看P的左孩子是否为空；
 2. 若P的左孩子不为空，则置P的左孩子为当前节点，重复1）的操作；
 3. 若P的左孩子为空，则将栈顶节点出栈，但不输出，并将出栈节点的右孩子置为当前节点，看其是否为空；
 4. 若不为空，则循环至1）操作；
 5. 如果为空，则继续出栈，但不输出，同时将出栈节点的右孩子置为当前节点，看其是否为空，重复4）和5）操作；
 6. 直到当前节点P为NULL并且栈空，遍历结束。

##### 中序遍历的非递归实现(投影遍历)

根据中序遍历的顺序，先访问左子树，再访问根节点，后访问右子树，而对于每个子树来说，又按照同样的访问顺序进行遍历，上图的中序遍历顺序为：DBEAFC。非递归的实现思路如下：
对于任一节点P，

 1. 若P的左孩子不为空，则将P入栈并将P的左孩子置为当前节点，然后再对当前节点进行相同的处理；
 2. 若P的左孩子为空，则输出P节点，而后将P的右孩子置为当前节点，看其是否为空；
 3. 若不为空，则重复1）和2）的操作；
 4. 若为空，则执行出栈操作，输出栈顶节点，并将出栈的节点的右孩子置为当前节点，看起是否为空，重复3）和4）的操作；
 5. 直到当前节点P为NULL并且栈为空，则遍历结束。

##### 后序遍历的非递归实现

根据后序遍历的顺序，先访问左子树，再访问右子树，后访问根节点，而对于每个子树来说，又按照同样的访问顺序进行遍历，上图的后序遍历顺序为：DEBFCA。
后序遍历的非递归的实现相对来说要难一些，要保证根节点在左子树和右子树被访问后才能访问，思路如下：

对于任一节点P，

 1. 先将节点P入栈；
 2. 若P不存在左孩子和右孩子，或者P存在左孩子或右孩子，但左右孩子已经被输出，则可以直接输出节点P，并将其出栈，将出栈节点P标记为上一个输出的节点，再将此时的栈顶结点设为当前节点；
 3. 若不满足2）中的条件，则将P的右孩子和左孩子依次入栈，当前节点重新置为栈顶结点，之后重复操作2）；
 4. 直到栈空，遍历结束。

#### 树的广度优先遍历/层序遍历

广度优先周游的方式是按层次从上到下，从左到右的逐层访问，不难想到，可以利用一个队列来实现。基本思想如下：

 - （1）首先把二叉树的根节点送入队列；
 - （2）队首的节点出队列并访问之，然后把它的右子节点和左子节点分别入队列；
 - （3）重复上面两步操作，直至队空。 
 
一层一批队列.